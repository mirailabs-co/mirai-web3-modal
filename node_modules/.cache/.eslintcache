[{"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/index.ts":"1","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/index.ts":"2","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/client.ts":"3","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/providers/mirai-provider.ts":"4","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/mirai-connector.ts":"5","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/controllers/auth-token.ts":"6","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/constants/index.ts":"7","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/types/index.ts":"8","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/actions/index.ts":"9","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/core/index.ts":"10","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/controllers/engine.ts":"11","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/connector.ts":"12","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/clients/wallet-client.ts":"13","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/storage.ts":"14","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/transports/websocket/ws-signer.ts":"15","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/constants/client.ts":"16","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/types/client.ts":"17","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/types/engine.ts":"18","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/index.ts":"19","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/actions/signMessage.ts":"20","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/core/config.ts":"21","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/query-utils.ts":"22","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/crypto-utils.ts":"23","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/transports/websocket/ws-base.ts":"24","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/transports/websocket/connection-wrapper.ts":"25"},{"size":299,"mtime":1692114903483,"results":"26","hashOfConfig":"27"},{"size":258,"mtime":1692091646438,"results":"28","hashOfConfig":"27"},{"size":3153,"mtime":1692157637628,"results":"29","hashOfConfig":"27"},{"size":10064,"mtime":1692114790421,"results":"30","hashOfConfig":"27"},{"size":6016,"mtime":1692156239820,"results":"31","hashOfConfig":"27"},{"size":1559,"mtime":1692083850113,"results":"32","hashOfConfig":"27"},{"size":26,"mtime":1692083850113,"results":"33","hashOfConfig":"27"},{"size":52,"mtime":1692083850114,"results":"34","hashOfConfig":"27"},{"size":31,"mtime":1692114868314,"results":"35","hashOfConfig":"27"},{"size":26,"mtime":1692156498300,"results":"36","hashOfConfig":"27"},{"size":3813,"mtime":1692096876074,"results":"37","hashOfConfig":"27"},{"size":2276,"mtime":1692114173433,"results":"38","hashOfConfig":"27"},{"size":660,"mtime":1692113531301,"results":"39","hashOfConfig":"27"},{"size":2011,"mtime":1692083850114,"results":"40","hashOfConfig":"27"},{"size":779,"mtime":1692114616418,"results":"41","hashOfConfig":"27"},{"size":2561,"mtime":1692083850113,"results":"42","hashOfConfig":"27"},{"size":2083,"mtime":1692113030431,"results":"43","hashOfConfig":"27"},{"size":761,"mtime":1692096855065,"results":"44","hashOfConfig":"27"},{"size":2661,"mtime":1692083850114,"results":"45","hashOfConfig":"27"},{"size":462,"mtime":1692114241383,"results":"46","hashOfConfig":"27"},{"size":456,"mtime":1692114167170,"results":"47","hashOfConfig":"27"},{"size":1345,"mtime":1692083850114,"results":"48","hashOfConfig":"27"},{"size":2972,"mtime":1692159639259,"results":"49","hashOfConfig":"27"},{"size":1618,"mtime":1692114585716,"results":"50","hashOfConfig":"27"},{"size":2155,"mtime":1692156911820,"results":"51","hashOfConfig":"27"},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"138kefs",{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"61"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65"},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":9,"source":"69"},{"filePath":"70","messages":"71","suppressedMessages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"73","messages":"74","suppressedMessages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","suppressedMessages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","suppressedMessages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","suppressedMessages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","suppressedMessages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":2,"source":"88"},{"filePath":"89","messages":"90","suppressedMessages":"91","errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92"},{"filePath":"93","messages":"94","suppressedMessages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"96","messages":"97","suppressedMessages":"98","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99"},{"filePath":"100","messages":"101","suppressedMessages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"103"},{"filePath":"104","messages":"105","suppressedMessages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"107","messages":"108","suppressedMessages":"109","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"110"},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"114","messages":"115","suppressedMessages":"116","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117"},{"filePath":"118","messages":"119","suppressedMessages":"120","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"121","messages":"122","suppressedMessages":"123","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124"},{"filePath":"125","messages":"126","suppressedMessages":"127","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128"},{"filePath":"129","messages":"130","suppressedMessages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"132","messages":"133","suppressedMessages":"134","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"135"},{"filePath":"136","messages":"137","suppressedMessages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/index.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/index.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/client.ts",["139","140","141","142","143"],[],"import { AuthToken } from '.';\nimport { Mode } from './constants';\nimport AuthEngine from './controllers/engine';\nimport { AuthClientTypes, AuthEngineTypes, IAuthClient } from './types';\nimport EventEmitter from 'events';\n\ninterface AuthClientProps {\n\tclientId: string;\n\tmode: Mode;\n}\n\nexport class AuthClient extends IAuthClient {\n\tpublic name: string;\n\tpublic autoStart: boolean = false;\n\n\tpublic engine: IAuthClient['engine'];\n\tpublic events: IAuthClient['events'] = new EventEmitter();\n\n\t// ---------- Events ----------------------------------------------- //\n\n\tpublic emit: IAuthClient['emit'] = (name, listener) => {\n\t\treturn this.events.emit(name, listener);\n\t};\n\n\tpublic on: IAuthClient['on'] = (name, listener) => {\n\t\treturn this.events.on(name, listener);\n\t};\n\n\tpublic once: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n\tpublic off: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n\tpublic removeListener: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n\n\tstatic async init(opts: AuthClientTypes.Options) {\n\t\tconst client = new AuthClient(opts);\n\t\tawait client.initialize();\n\n\t\treturn client;\n\t}\n\n\tconstructor(opts: AuthClientTypes.Options) {\n\t\tsuper(opts);\n\n\t\tthis.name = opts?.name;\n\t\tthis.clientId = opts.clientId;\n\t\tthis.mode = opts.mode;\n\t\tthis.autoStart = opts.autoStart;\n\t\tthis.authorizationCallbackFunc = opts.authorizationCallbackFunc;\n\t\tthis.engine = new AuthEngine(this);\n\t}\n\n\tprivate setAuthorizationListener = (\n\t\tcallback: ({ code, state }: { code: string; state: string }, error: any) => Promise<void>,\n\t) => {\n\t\tthis.on('auth_response', async ({ params }) => {\n\t\t\tconst { code, state } = params;\n\t\t\tconsole.log('Listener received params', code, state);\n\t\t\tif (code && state) {\n\t\t\t\ttypeof callback === 'function' && (await callback({ code, state }, ''));\n\t\t\t}\n\t\t});\n\n\t\tconsole.log(`Initialized Listener`);\n\t};\n\n\t// ---------- Engine ----------------------------------------------- //\n\t// request authentication\n\tpublic request: IAuthClient['request'] = async (params: AuthEngineTypes.RequestParams) => {\n\t\ttry {\n\t\t\tawait this.engine.request(params);\n\t\t} catch (error: any) {\n\t\t\tthrow error;\n\t\t}\n\t};\n\n\tpublic start = async () => {\n\t\tconsole.info('Starting subcribe authorization response ...');\n\t\tawait this.setAuthorizationListener(this.authorizationCallbackFunc);\n\n\t\tawait this.engine.registerOnAuthResponse();\n\n\t\tconsole.info('Started subcribe authorization response !!!');\n\t};\n\n\t// ---------- Private ----------------------------------------------- //\n\tprivate async initialize() {\n\t\tconsole.log(`Initialized`);\n\t\ttry {\n\t\t\tawait AuthToken.initInstanceStorage();\n\t\t\tawait this.engine.init();\n\n\t\t\tconsole.info(`AuthClient Initialization Success`);\n\t\t\tconsole.info({ authClient: this });\n\n\t\t\tif (this.autoStart) {\n\t\t\t\tawait this.start();\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\tconsole.info(`AuthClient Initialization Failure`);\n\t\t\tconsole.error(error.message);\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/providers/mirai-provider.ts",["144","145","146","147","148","149","150","151","152"],[],"import { EventEmitter } from 'events';\nimport {\n\tIEthereumProvider as IProvider,\n\tIEthereumProviderEvents,\n\tProviderAccounts,\n\tRequestArguments,\n\tProviderChainId,\n} from './types';\nimport { SignerWebSocketService } from '../transports/websocket/ws-signer';\n\nexport type RpcMethod =\n\t| 'personal_sign'\n\t| 'eth_sendTransaction'\n\t| 'eth_accounts'\n\t| 'eth_requestAccounts'\n\t| 'eth_call'\n\t| 'eth_getBalance'\n\t| 'eth_sendRawTransaction'\n\t| 'eth_sign'\n\t| 'eth_signTransaction'\n\t| 'eth_signTypedData'\n\t| 'eth_signTypedData_v3'\n\t| 'eth_signTypedData_v4'\n\t| 'wallet_switchEthereumChain'\n\t| 'wallet_addEthereumChain'\n\t| 'wallet_getPermissions'\n\t| 'wallet_requestPermissions'\n\t| 'wallet_registerOnboarding'\n\t| 'wallet_watchAsset'\n\t| 'wallet_scanQRCode';\n\nexport type RpcEvent = 'accountsChanged' | 'chainChanged' | 'message' | 'disconnect' | 'connect';\n\nexport interface EthereumRpcMap {\n\t[chainId: string]: string;\n}\n\nexport interface SessionEvent {\n\tevent: { name: string; data: any };\n\tchainId: string;\n}\n\nexport interface EthereumRpcConfig {\n\tchains: string[];\n\toptionalChains: string[];\n\tmethods: string[];\n\toptionalMethods?: string[];\n\t/**\n\t * @description Events that the wallet MUST support or the connection will be rejected\n\t */\n\tevents: string[];\n\toptionalEvents?: string[];\n\trpcMap: EthereumRpcMap;\n}\n\nexport interface ConnectOps {\n\tchains?: number[];\n\toptionalChains?: number[];\n\trpcMap?: EthereumRpcMap;\n\tpairingTopic?: string;\n\tchainId: number;\n}\n\nexport interface IEthereumProvider extends IProvider {\n\tconnect(opts?: ConnectOps | undefined): Promise<WalletConnectSession>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n\tlet rpcUrl: string | undefined;\n\tif (rpc.rpcMap) {\n\t\trpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n\t}\n\treturn rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n\treturn Number(chains[0].split(':')[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n\treturn `0x${chainId.toString(16)}`;\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n\t0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n\t| {\n\t\t\tchains: ArrayOneOrMore<number>;\n\t\t\toptionalChains?: number[];\n\t  }\n\t| {\n\t\t\tchains?: number[];\n\t\t\toptionalChains: ArrayOneOrMore<number>;\n\t  };\n\nexport type EthereumProviderOptions = {\n\tmethods?: string[];\n\t/**\n\t * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n\t */\n\toptionalMethods?: string[];\n\tevents?: string[];\n\toptionalEvents?: string[];\n\trpcMap?: EthereumRpcMap;\n} & ChainsProps;\n\nexport type WalletConnectSession = {\n\ttopic: string;\n\texpiry: number;\n\tacknowledged: boolean;\n\tpairingTopic: string;\n\tcontroller: string;\n\tpeer: {\n\t\tpublicKey: string;\n\t\tmetadata: {\n\t\t\tname: string;\n\t\t\tdescription: string;\n\t\t\turl: string;\n\t\t\ticons: [];\n\t\t};\n\t};\n\tnamespaces?: {\n\t\taccounts: string[];\n\t\tevents: string[];\n\t};\n};\n\nexport class MiraiProvider implements IEthereumProvider {\n\tpublic emitter = new EventEmitter();\n\tpublic accounts: string[] = [];\n\tprivate _signer: InstanceType<typeof SignerWebSocketService>;\n\tpublic chainId = 1;\n\n\tprotected rpc: EthereumRpcConfig;\n\n\tconstructor() {\n\t\t// assigned during initialize\n\t\tthis._signer = new SignerWebSocketService();\n\t\tthis.rpc = {} as EthereumRpcConfig;\n\t}\n\n\tstatic async init(opts: EthereumProviderOptions): Promise<MiraiProvider> {\n\t\tconst provider = new MiraiProvider();\n\t\tawait provider.initialize(opts);\n\n\t\treturn provider;\n\t}\n\n\tpublic async request<T = unknown>(args: RequestArguments): Promise<T> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst socket = await this._signer.establish(true);\n\n\t\t\tsocket.internal().once(args.method, (message: string) => {\n\t\t\t\tconsole.log(':message', message);\n\t\t\t});\n\n\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\tsocket.disconnect();\n\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t});\n\n\t\t\tsocket.on('connect', () => {\n\t\t\t\tconsole.log('emitted', args);\n\t\t\t\tsocket.getSocket().emit(args.method, args.params, (data: T & { code: number; message: string }) => {\n\t\t\t\t\tconsole.log('data receive method', data);\n\n\t\t\t\t\tif (data.code) {\n\t\t\t\t\t\treject(new Error(data.message));\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tsocket.on('connect_error', () => {\n\t\t\t\treject(new Error('Connection error'));\n\t\t\t});\n\n\t\t\tsocket.connect();\n\t\t});\n\t}\n\n\tpublic async enable(): Promise<ProviderAccounts> {\n\t\tconst accounts = await this.request({ method: 'eth_requestAccounts' });\n\t\treturn accounts as ProviderAccounts;\n\t}\n\n\tpublic async getChainId(): Promise<ProviderChainId> {\n\t\tconst chain = await this.request({ method: 'eth_chainId' });\n\n\t\tconsole.log('chain', chain);\n\t\treturn chain as ProviderChainId;\n\t}\n\n\tpublic async connect(opts?: ConnectOps): Promise<WalletConnectSession> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst socket = await this._signer.establish(true);\n\n\t\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\t\tsocket.disconnect();\n\t\t\t\t\tconsole.log('disconnect');\n\n\t\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t\t});\n\n\t\t\t\tsocket.on('connect', (e: any) => {\n\t\t\t\t\tconsole.log('connected');\n\t\t\t\t});\n\n\t\t\t\tsocket.on('connect_error', () => {\n\t\t\t\t\treject(new Error('Connection error'));\n\t\t\t\t});\n\n\t\t\t\tsocket.on('session', (resp: any) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (resp.code === 0) {\n\t\t\t\t\t\t\tthrow new Error(JSON.stringify(resp.data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst { namespaces } = resp.data as WalletConnectSession;\n\n\t\t\t\t\t\t// if(namespaces['eip155']){\n\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t// this.setAccounts(namespaces['eip155']['accounts']);\n\t\t\t\t\t\tresolve(resp.data);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tsocket.on('chainChanged', (resp: any) => {\n\t\t\t\t\tconsole.log('chains', resp);\n\t\t\t\t\tif (resp.code === 0) {\n\t\t\t\t\t\tthrow new Error(JSON.stringify(resp.data));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst chainId = resp.data as number;\n\n\t\t\t\t\tthis.setChainId(chainId);\n\t\t\t\t});\n\n\t\t\t\tsocket.on('accountsChanged', (resp: any) => {\n\t\t\t\t\tif (resp.code === 0) {\n\t\t\t\t\t\tthrow new Error(JSON.stringify(resp.data));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst accounts = resp.data as string[];\n\n\t\t\t\t\tthis.setAccounts(this.parseAccounts(accounts));\n\t\t\t\t});\n\n\t\t\t\tsocket.connect();\n\t\t\t\tthis.setChainIds(this.rpc.chains);\n\t\t\t\tthis.emitter.emit('connect', { chainId: toHexChainId(this.chainId) });\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async disconnect(): Promise<void> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst socket = await this._signer.establish(true);\n\n\t\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\t\tsocket.disconnect();\n\t\t\t\t\tconsole.log('disconnect');\n\n\t\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t\t});\n\n\t\t\t\tconsole.time('WS get-pail');\n\t\t\t\tsocket.on('connect', () => {\n\t\t\t\t\tconsole.log('connected');\n\t\t\t\t});\n\n\t\t\t\tsocket.on('connect_error', () => {\n\t\t\t\t\treject(new Error('Connection error'));\n\t\t\t\t});\n\n\t\t\t\tsocket.disconnect();\n\t\t\t\tthis.emitter.emit('disconnect', {});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic on: IEthereumProviderEvents['on'] = (event, listener) => {\n\t\tthis.emitter.on(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic once: IEthereumProviderEvents['once'] = (event, listener) => {\n\t\tthis.emitter.once(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic removeListener: IEthereumProviderEvents['removeListener'] = (event, listener) => {\n\t\tthis.emitter.removeListener(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic off: IEthereumProviderEvents['off'] = (event, listener) => {\n\t\tthis.emitter.off(event, listener);\n\t\treturn this;\n\t};\n\n\tget isWalletConnect() {\n\t\treturn true;\n\t}\n\n\tprotected switchEthereumChain(chainId: number): void {\n\t\tthis.request({\n\t\t\tmethod: 'wallet_switchEthereumChain',\n\t\t\tparams: [{ chainId: chainId.toString(16) }],\n\t\t});\n\t}\n\n\tprotected parseChainId(chainId: string): number {\n\t\treturn Number(chainId.split(':')[1]);\n\t}\n\n\tprotected setChainIds(chains: string[]) {\n\t\tthis.emitter.emit('chainChanged', toHexChainId(this.chainId));\n\t\tthis.persist();\n\t}\n\n\tprotected setChainId(chain: number) {\n\t\tthis.switchEthereumChain(chain);\n\t}\n\n\tprotected parseAccountId(account: string): { chainId: string; address: string } {\n\t\tconst [namespace, reference, address] = account.split(':');\n\t\tconst chainId = `${namespace}:${reference}`;\n\t\treturn { chainId, address };\n\t}\n\n\tprotected setAccounts(accounts: string[]) {\n\t\tthis.accounts = accounts.map((x) => this.parseAccountId(x).address);\n\t\tthis.emitter.emit('accountsChanged', this.accounts);\n\t}\n\n\tprotected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n\t\tconst map: EthereumRpcMap = {};\n\t\tchains.forEach((chain) => {\n\t\t\tmap[chain] = this.getRpcUrl(chain, projectId);\n\t\t});\n\t\treturn map;\n\t}\n\n\tprotected async initialize(opts: EthereumProviderOptions) {\n\t\t// this.chainId = this.rpc.chains.length\n\t\t//     ? getEthereumChainId(this.rpc.chains)\n\t\t//     : getEthereumChainId(this.rpc.optionalChains);\n\t\t// await this.registerEventListeners();\n\t\t// await this.loadPersistedSession();\n\t}\n\n\tprotected getRpcUrl(chainId: number, projectId?: string): string {\n\t\treturn this.rpc.rpcMap?.[chainId];\n\t}\n\n\tprotected reset() {\n\t\tthis.chainId = 1;\n\t\tthis.accounts = [];\n\t}\n\n\tprotected persist() {}\n\n\tprotected parseAccounts(payload: string | string[]): string[] {\n\t\tif (typeof payload === 'string' || payload instanceof String) {\n\t\t\treturn [this.parseAccount(payload)];\n\t\t}\n\t\treturn payload.map((account: string) => this.parseAccount(account));\n\t}\n\n\tprotected parseAccount = (payload: any): string => {\n\t\tconsole.log('payload', payload);\n\t\treturn this.parseAccountId(payload).address;\n\t};\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/mirai-connector.ts",["153","154","155","156","157","158","159","160","161","162","163","164","165","166","167"],[],"import { Connector } from '../connectors/connector';\nimport { MiraiProvider, ConnectOps } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { WalletClient, createWalletClient } from '../clients/wallet-client';\nimport { Chain } from '../services/core/config';\n\nconst ETH_CHAIN_ID = 1;\n\nconst getPeer = (peer: {\n\tpublicKey: string;\n\tmetadata: {\n\t\tname: string;\n\t\tdescription: string;\n\t\turl: string;\n\t\ticons: [];\n\t};\n}) => {};\n\nexport class MiraiConnector extends Connector<MiraiProvider, any> {\n\treadonly id = 'miraijsConnect';\n\treadonly name = 'miraijsConnect';\n\treadonly ready = true;\n\n\tprovider?: MiraiProvider;\n\n\tconstructor(config: { chains?: Chain[]; options: any }) {\n\t\tsuper({\n\t\t\t...config,\n\t\t\toptions: { isNewChainsStale: true, ...config.options },\n\t\t});\n\t\tthis.createProvider();\n\t}\n\n\tasync connect({ chainId, pairingTopic }: ConnectOps = { chainId: ETH_CHAIN_ID }) {\n\t\ttry {\n\t\t\tconst provider = await this.getProvider();\n\t\t\tthis.setupListeners();\n\n\t\t\tthis.emit('message', { type: 'connecting. scan qrcode ...' });\n\n\t\t\tawait provider.connect({\n\t\t\t\tpairingTopic,\n\t\t\t\tchains: [chainId],\n\t\t\t\tchainId,\n\t\t\t});\n\n\t\t\tthis.emit('message', { type: 'connected' });\n\n\t\t\t// If session exists and chains are authorized, enable provider for required chain\n\t\t\tconst accounts = await provider.enable();\n\n\t\t\t// await this.switchChain(chainId);\n\n\t\t\tconsole.log('accounts', accounts);\n\n\t\t\tconst account = ethers.getAddress(accounts[0]);\n\t\t\tconst chain = await provider.getChainId();\n\t\t\tconst id = Number(parseInt(chain, 16));\n\t\t\tconst unsupported = this.isChainUnsupported(id);\n\n\t\t\tconsole.log('chainid', id);\n\n\t\t\treturn {\n\t\t\t\taccount,\n\t\t\t\tchain: { id, unsupported },\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getWalletClient({ chainId }: { chainId?: number } = {}): Promise<WalletClient> {\n\t\tconst [provider, account] = await Promise.all([this.getProvider({ chainId }), this.getAccount()]);\n\t\t// const chain = this.chains.find((x) => x.id === chainId);\n\t\tif (!provider) throw new Error('provider is required.');\n\t\treturn createWalletClient({\n\t\t\taccount,\n\t\t\tchainId,\n\t\t\tprovider,\n\t\t});\n\t}\n\n\tasync disconnect() {\n\t\tconst provider = await this.getProvider();\n\t\ttry {\n\t\t\tawait provider.disconnect();\n\t\t} catch (error) {\n\t\t\tif (!/No matching key/i.test((error as Error).message)) throw error;\n\t\t} finally {\n\t\t\tthis.removeAllListeners();\n\t\t}\n\t}\n\n\tasync getAccount(): Promise<string> {\n\t\tconst { accounts } = await this.getProvider();\n\n\t\tconsole.log('getAccount', accounts);\n\t\treturn ethers.getAddress(accounts[0]!);\n\t}\n\n\tasync getChainId() {\n\t\tconst { chainId, getChainId, request } = await this.getProvider();\n\t\tif (!chainId) {\n\t\t\tconst chain = await getChainId();\n\t\t\tconsole.log('chain', chain);\n\t\t\treturn Number(chain.split(':')[1]);\n\t\t}\n\t\treturn chainId;\n\t}\n\n\tasync getProvider({ chainId }: { chainId?: number } = {}) {\n\t\tif (!this.provider) await this.createProvider();\n\t\tif (chainId) await this.switchChain(chainId || this.chains[0].id);\n\t\treturn this.provider;\n\t}\n\n\tasync isAuthorized() {\n\t\ttry {\n\t\t\tconst [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n\t\t\t// If an account does not exist on the session, then the connector is unauthorized.\n\t\t\tif (!account) return false;\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync switchChain(chainId: number) {\n\t\tconst chain = this.chains.find((chain) => chain.id === chainId);\n\t\t// if (!chain) throw new Error('chain not found on connector.');\n\t\t// if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n\t\ttry {\n\t\t\t// const provider = await this.getProvider();\n\n\t\t\t// const chains = await provider.request({\n\t\t\t//     method: 'wallet_switchEthereumChain',\n\t\t\t//     params: [{ chainId: `${ethers.toBeHex(chainId)}` }],\n\t\t\t// });\n\n\t\t\t// console.log('chains', chains);\n\n\t\t\treturn chain;\n\t\t} catch (error) {\n\t\t\tconsole.log('error', error);\n\t\t\t// const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n\t\t\t// if (/user rejected request/i.test(message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\t// throw new SwitchChainError(error as Error);\n\t\t}\n\t}\n\n\tasync createProvider() {\n\t\treturn this.initProvider();\n\t}\n\n\tasync initProvider() {\n\t\tconst [defaultChain, ...optionalChains] = this.chains.map(({ id }) => id);\n\t\tif (defaultChain) {\n\t\t\tthis.provider = await MiraiProvider.init({\n\t\t\t\tchains: [defaultChain],\n\t\t\t\t// rpcMap: Object.fromEntries(this.chains.map((chain) => [chain.id, chain.rpcUrls.default.http[0]!])),\n\t\t\t});\n\t\t}\n\n\t\tconsole.log('provider', this.provider);\n\t}\n\n\tsetupListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.removeListeners();\n\t\tthis.provider.on('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.on('chainChanged', this.onChainChanged);\n\t\tthis.provider.on('disconnect', this.onDisconnect);\n\t\tthis.provider.on('connect', this.onConnect);\n\t}\n\n\tremoveListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.provider.removeListener('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.removeListener('chainChanged', this.onChainChanged);\n\t\tthis.provider.removeListener('disconnect', this.onDisconnect);\n\t\tthis.provider.removeListener('connect', this.onConnect);\n\t}\n\n\tprotected onAccountsChanged = (accounts: string[]) => {\n\t\tif (accounts.length === 0) this.emit('disconnect');\n\t\telse this.emit('change', { account: ethers.getAddress(accounts[0]!) });\n\t};\n\n\tprotected onChainChanged = (chainId: number | string) => {\n\t\tconst id = Number(chainId);\n\t\tconst unsupported = this.isChainUnsupported(id);\n\t\tthis.emit('change', { chain: { id, unsupported } });\n\t};\n\n\tprotected onDisconnect = () => {\n\t\tthis.emit('disconnect');\n\t};\n\n\tprotected onDisplayUri = (uri: string) => {\n\t\tthis.emit('message', { type: 'display_uri', data: uri });\n\t};\n\n\tprotected onConnect = () => {\n\t\tthis.emit('connect', {});\n\t};\n}\n\n// export default MiraiConnector;\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/controllers/auth-token.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/constants/index.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/types/index.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/actions/index.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/core/index.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/controllers/engine.ts",["168","169","170","171","172","173","174"],[],"import { Mode, env } from '../constants';\nimport { AuthClientTypes, AuthEngineTypes, IAuthEngine } from '../types';\nimport { DefaultCrypto } from '../utils/crypto-utils';\nimport { BasicQueryStringUtils } from '../utils/query-utils';\nimport { LocalStorageBackend, StorageBackend } from '../utils/storage';\n\nclass AuthEngine extends IAuthEngine {\n\tpublic name: string = 'MiraiAuth';\n\tprivate initialized = false;\n\n\tprivate storageBackend: StorageBackend;\n\tprivate utils: BasicQueryStringUtils;\n\tprivate crypto: DefaultCrypto;\n\n\tconstructor(client: IAuthEngine['client']) {\n\t\tsuper(client);\n\t\tthis.storageBackend = new LocalStorageBackend();\n\t\tthis.utils = new BasicQueryStringUtils();\n\t\tthis.crypto = new DefaultCrypto();\n\t}\n\n\tpublic init(): void {\n\t\tif (!this.initialized) {\n\t\t\tthis.initialized = true;\n\t\t}\n\t}\n\n\tpublic async registerOnAuthResponse(): Promise<void> {\n\t\treturn await this.onAuthResponse();\n\t}\n\n\tpublic getApiUrl = () => {\n\t\tif (this.client.mode === 'development') {\n\t\t\treturn env.MIRAI_ID_API_URL_DEV;\n\t\t}\n\n\t\treturn env.MIRAI_ID_API_URL_PROD;\n\t};\n\n\tpublic async request(params: AuthEngineTypes.RequestParams): Promise<void> {\n\t\tawait this.performAuthorizationRequest(params);\n\t}\n\n\tprotected setExpiry(topic: string, expiry: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tprotected onAuthRequest(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\t// PRIVATE\n\tprivate performAuthorizationRequest = async (request: AuthEngineTypes.RequestParams): Promise<any> => {\n\t\tconst handle = this.crypto.generateRandom(10);\n\n\t\tconsole.log('making handle', handle);\n\n\t\t// before you make request, persist all request related data in local storage.\n\t\tconst persisted = Promise.all([\n\t\t\tthis.storageBackend.setItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY, handle),\n\t\t\t// Calling toJson() adds in the code & challenge when possible\n\t\t\tthis.storageBackend.setItem(this._authorizationRequestKey(handle), JSON.stringify(request)),\n\t\t]);\n\n\t\tpersisted.then(async () => {\n\t\t\ttry {\n\t\t\t\t// make the redirect request\n\t\t\t\tconsole.log(\n\t\t\t\t\t'Making a request to ',\n\t\t\t\t\t`${this.getApiUrl()}/api/auth/login?client_id=${this.client.clientId}&redirect_uri=${\n\t\t\t\t\t\trequest.redirect_uri\n\t\t\t\t\t}&code_challenge_method=${request.code_challenge_method}`,\n\t\t\t\t);\n\n\t\t\t\twindow.location.assign(\n\t\t\t\t\t`${this.getApiUrl()}/api/auth/login?client_id=${this.client.clientId}&redirect_uri=${\n\t\t\t\t\t\trequest.redirect_uri\n\t\t\t\t\t}&code_challenge_method=${request.code_challenge_method}`,\n\t\t\t\t);\n\t\t\t} catch (e) {}\n\t\t});\n\t};\n\n\tprotected onAuthResponse(): void {\n\t\tthis.storageBackend.getItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY).then((handle: any) => {\n\t\t\tif (handle) {\n\t\t\t\treturn this.storageBackend.getItem(this._authorizationRequestKey(handle)).then((payload: any) => {\n\t\t\t\t\t// cleanup state\n\t\t\t\t\treturn Promise.all([\n\t\t\t\t\t\t// this.storageBackend.removeItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY),\n\t\t\t\t\t\t// this.storageBackend.removeItem(this._authorizationRequestKey(handle)),\n\t\t\t\t\t]).then(() => {\n\t\t\t\t\t\tconsole.log('Delivering authorization response');\n\t\t\t\t\t\tlet queryParams = this.utils.parse(window.location, false /* use hash */);\n\t\t\t\t\t\tlet state: string | undefined = queryParams['state'];\n\t\t\t\t\t\tlet code: string | undefined = queryParams['code'];\n\n\t\t\t\t\t\tconsole.log(`we're received code=${code} and state=${state}`);\n\n\t\t\t\t\t\tif (code && state) {\n\t\t\t\t\t\t\tthis.client.emit('auth_response', { params: { code, state } });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/** key for authorization request. */\n\t_authorizationRequestKey = (handle: string) => {\n\t\treturn `${handle}_appauth_authorization_request`;\n\t};\n\n\t/** key in local storage which represents the current authorization request. */\n\t_AUTHORIZATION_REQUEST_HANDLE_KEY = 'appauth_current_authorization_request';\n}\n\nexport default AuthEngine;\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/connector.ts",["175","176","177"],[],"import { WalletClient } from '../../sign-provider/clients/wallet-client';\nimport { default as EventEmitter } from 'eventemitter3';\nimport { Chain } from '../services/core/config';\n\nexport type Address = `0x${string}`;\n\nexport type ConnectorData = {\n\taccount?: string;\n\tchain?: { id: number; unsupported: boolean };\n};\n\ntype BlockExplorer = {\n\tname: string;\n\turl: string;\n};\n\nexport type ConnectorEvents = 'change' | 'connect' | 'message' | 'disconnect' | 'error';\n\nexport abstract class Connector<Provider = any, Options = any> extends EventEmitter<ConnectorEvents> {\n\t/** Unique connector id */\n\tabstract readonly id: string;\n\t/** Connector name */\n\tabstract readonly name: string;\n\t/** Chains connector supports */\n\treadonly chains: Chain[];\n\t/** Options to use with connector */\n\treadonly options: Options;\n\t/** Connector storage. */\n\tprotected storage?: Storage;\n\t/** Whether connector is usable */\n\tabstract readonly ready: boolean;\n\n\tconstructor({ chains = [], options }: { chains?: Chain[]; options: Options }) {\n\t\tsuper();\n\t\tthis.chains = chains;\n\t\tthis.options = options;\n\t}\n\tstart: () => void;\n\n\tabstract connect(config?: { chainId?: number }): Promise<Required<ConnectorData>>;\n\tabstract disconnect(): Promise<void>;\n\tabstract getAccount(): Promise<string>;\n\tabstract getChainId(): Promise<number>;\n\tabstract getProvider(config?: { chainId?: number }): Promise<Provider>;\n\tabstract isAuthorized(): Promise<boolean>;\n\tswitchChain?(chainId: number): Promise<Chain>;\n\twatchAsset?(asset: { address: string; decimals?: number; image?: string; symbol: string }): Promise<boolean>;\n\tabstract getWalletClient({ chainId }: { chainId?: number }): Promise<WalletClient>;\n\n\tprotected abstract onAccountsChanged(accounts: string[]): void;\n\tprotected abstract onChainChanged(chain: number | string): void;\n\tprotected abstract onDisconnect(error: Error): void;\n\n\t// protected getBlockExplorerUrls(chain: Chain) {\n\t// \tconst { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};\n\t// \tif (blockExplorer) return [blockExplorer.url, ...Object.values(blockExplorers).map((x) => x.url)];\n\t// }\n\n\tprotected isChainUnsupported(chainId: number) {\n\t\treturn !this.chains.some((x) => x.id === chainId);\n\t}\n\n\tsetStorage(storage: Storage) {\n\t\tthis.storage = storage;\n\t}\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/clients/wallet-client.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/storage.ts",["178","179","180","181"],[],"export interface UnderlyingStorage {\n\treadonly length: number;\n\tclear(): void;\n\tgetItem(key: string): string | null;\n\tremoveItem(key: string): void;\n\tsetItem(key: string, data: string): void;\n}\n\n/**\n * Asynchronous storage APIs. All methods return a `Promise`.\n * All methods take the `DOMString`\n * IDL type (as it is the lowest common denominator).\n */\nexport abstract class StorageBackend {\n\t/**\n\t * When passed a key `name`, will return that key's value.\n\t */\n\tpublic abstract getItem(name: string): Promise<string | null>;\n\n\t/**\n\t * When passed a key `name`, will remove that key from the storage.\n\t */\n\tpublic abstract removeItem(name: string): Promise<void>;\n\n\t/**\n\t * When invoked, will empty all keys out of the storage.\n\t */\n\tpublic abstract clear(): Promise<void>;\n\n\t/**\n\t * The setItem() method of the `StorageBackend` interface,\n\t * when passed a key name and value, will add that key to the storage,\n\t * or update that key's value if it already exists.\n\t */\n\tpublic abstract setItem(name: string, value: string): Promise<void>;\n}\n\n/**\n * A `StorageBackend` backed by `localstorage`.\n */\nexport class LocalStorageBackend extends StorageBackend {\n\tprivate storage: UnderlyingStorage;\n\tconstructor(storage?: UnderlyingStorage) {\n\t\tsuper();\n\t\tthis.storage = storage || window.localStorage;\n\t}\n\n\tpublic getItem(name: string): Promise<string | null> {\n\t\treturn new Promise<string | null>((resolve, reject) => {\n\t\t\tconst value = this.storage.getItem(name);\n\t\t\tif (value) {\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\tresolve(null);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic removeItem(name: string): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tthis.storage.removeItem(name);\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic clear(): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tthis.storage.clear();\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic setItem(name: string, value: string): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tthis.storage.setItem(name, value);\n\t\t\tresolve();\n\t\t});\n\t}\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/transports/websocket/ws-signer.ts",["182"],[],"/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { io } from 'socket.io-client';\nimport { WebSocketConnection } from './connection-wrapper';\nimport { BaseWebSocketService } from './ws-base';\n\nexport class SignerWebSocketService extends BaseWebSocketService {\n\tpublic establish = async (acknowledgement?: boolean): Promise<WebSocketConnection> => {\n\t\tconst headers = await this.getHeaders();\n\n\t\tconst socket = io(`${'ws://localhost:3000'}`, {\n\t\t\t// const socket = io(`${'wss://id-api-dev.mirailabs.co/mpc'}`, {\n\t\t\tautoConnect: false,\n\t\t\treconnection: false,\n\t\t\ttransportOptions: {\n\t\t\t\twebsocket: {\n\t\t\t\t\textraHeaders: headers,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttransports: ['websocket'],\n\t\t\textraHeaders: headers,\n\t\t});\n\n\t\treturn new WebSocketConnection(socket, acknowledgement);\n\t};\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/constants/client.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/types/client.ts",["183","184"],[],"import { Mode } from '../constants';\nimport EventEmitter from 'events';\nimport { AuthEngineTypes, IAuthEngine } from './engine';\n\nexport declare namespace AuthClientTypes {\n\ttype Event = 'auth_request' | 'auth_response';\n\n\tinterface AuthRequestEventArgs {\n\t\trequester: string;\n\t}\n\n\ttype AuthResponseEventArgs = { code: string; state: string };\n\n\tinterface BaseEventArgs<T = unknown> {\n\t\tparams: T;\n\t}\n\n\tinterface EventArguments {\n\t\tauth_request: BaseEventArgs<AuthRequestEventArgs>;\n\t\tauth_response: BaseEventArgs<AuthResponseEventArgs>;\n\t}\n\n\tinterface Options {\n\t\tmode: Mode;\n\t\tclientId: string;\n\t\tname: string;\n\t\tauthorizationCallbackFunc: ({ code, state }: { code: string; state: string }, error: any) => Promise<void>;\n\t\tautoStart?: boolean;\n\t}\n}\n\nexport abstract class IAuthClient {\n\tpublic abstract readonly name: string;\n\tpublic mode: Mode;\n\tpublic clientId: string;\n\tpublic authorizationCallbackFunc: ({ code, state }: { code: string; state: string }, error: any) => Promise<void>;\n\n\tpublic abstract engine: IAuthEngine;\n\tpublic abstract events: EventEmitter;\n\n\tconstructor(opts: AuthClientTypes.Options) {}\n\n\t// ---------- Public Methods ----------------------------------------------- //\n\tpublic abstract request: IAuthEngine['request'];\n\n\t// ---------- Event Handlers ----------------------------------------------- //\n\tpublic abstract emit: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\targs: AuthClientTypes.EventArguments[E],\n\t) => boolean;\n\n\tpublic abstract on: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n\n\tpublic abstract once: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n\n\tpublic abstract off: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n\n\tpublic abstract removeListener: <E extends AuthClientTypes.Event>(\n\t\tevent: E,\n\t\tlistener: (args: AuthClientTypes.EventArguments[E]) => void,\n\t) => EventEmitter;\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/types/engine.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/index.ts",["185","186"],[],"import { AuthToken } from '../controllers/auth-token';\n\n// GENERATING CODE VERIFIER\nfunction dec2hex(dec: any) {\n    return ('0' + dec.toString(16)).substr(-2);\n}\n\nexport function generateCodeVerifier() {\n    var array = new Uint32Array(56 / 2);\n    window.crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join('');\n}\n\nexport const validateJwt = (token: string, buffer: number = 0) => {\n    try {\n        const now = Math.round(Date.now() / 1000);\n        const parts = token.split('.');\n\n        const JWT_TOKEN_PART_LENGTH = 3;\n\n        if (parts.length !== JWT_TOKEN_PART_LENGTH) {\n            throw new Error('Not a valid JWT');\n        }\n\n        // Get middle part in payload string\n        const payload = JSON.parse(parts[1]);\n\n        // For offline_access refreshToken\n        if (!payload.exp) {\n            return true;\n        }\n\n        if (payload.exp && now >= payload.exp + buffer) {\n            throw new Error('Token expired');\n        }\n\n        return true;\n    } catch (e) {\n        console.log(e.message);\n    }\n    return false;\n};\n\nexport const createAuthHeaders = async () => {\n    const authHeaders: Record<string, string> = {};\n    const token = await AuthToken.get();\n\n    if (token) {\n        authHeaders.Authorization = `Bearer ${token?.access_token}`;\n    }\n\n    return authHeaders;\n};\n\nexport const getErrorMessage = (e: any): string => {\n    console.log(e);\n    let message: string = '';\n    try {\n        if (e.data && e.data.message) {\n            const error_message = e.data.message\n                .replace('execution reverted: ', '')\n                .replace('execution reverted', '')\n                .trim();\n\n            if (error_message === '') {\n                message = 'Unknown Metamask response error!';\n            }\n\n            message = error_message;\n        } else if (e.reason) {\n            // prettier-ignore\n            const error_message = e.reason\n\t\t\t\t.replace('execution reverted: ', '')\n\t\t\t\t.replace('execution reverted', '')\n\t\t\t\t.trim();\n\n            if (error_message === '') {\n                message = 'Unknown Metamask response error!';\n            }\n\n            message = error_message;\n        } else if (e.networkError?.result) {\n            message = e.networkError?.result.message;\n        } else if (e.error) {\n            message = e.error?.message;\n        } else {\n            message = e.message;\n        }\n\n        const regex = /(.*?)\\(/g;\n\n        if (message.match(regex)) {\n            const match = regex.exec(message);\n            if (match) {\n                message = match[1].trim();\n            }\n        }\n    } catch (e) {}\n\n    return message;\n};\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/actions/signMessage.ts",[],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/services/core/config.ts",["187"],[],"export type Chain = {\n\t/** ID in number form */\n\tid: number;\n\t/** Human-readable name */\n\tname: string;\n\t/** Internal network name */\n\tnetwork: string;\n\t/** Currency used by chain */\n\tnativeCurrency: NativeCurrency;\n\t/** Flag for test networks */\n\ttestnet?: boolean;\n};\n\ntype NativeCurrency = {\n\tname: string;\n\t/** 2-6 characters long */\n\tsymbol: string;\n\tdecimals: number;\n};\n\ntype RpcUrls = {\n\thttp: readonly string[];\n\twebSocket?: readonly string[];\n};\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/query-utils.ts",["188","189"],[],"export interface StringMap {\n\t[key: string]: string;\n}\n\n/**\n * Query String Utilities.\n */\nexport interface QueryStringUtils {\n\tstringify(input: StringMap): string;\n\tparse(query: Location, useHash?: boolean): StringMap;\n\tparseQueryString(query: string): StringMap;\n}\n\nexport class BasicQueryStringUtils implements QueryStringUtils {\n\tparse(input: Location, useHash?: boolean) {\n\t\tif (useHash) {\n\t\t\treturn this.parseQueryString(input.hash);\n\t\t} else {\n\t\t\treturn this.parseQueryString(input.search);\n\t\t}\n\t}\n\n\tparseQueryString(query: string): StringMap {\n\t\tlet result: StringMap = {};\n\t\t// if anything starts with ?, # or & remove it\n\t\tquery = query.trim().replace(/^(\\?|#|&)/, '');\n\t\tlet params = query.split('&');\n\t\tfor (let i = 0; i < params.length; i += 1) {\n\t\t\tlet param = params[i]; // looks something like a=b\n\t\t\tlet parts = param.split('=');\n\t\t\tif (parts.length >= 2) {\n\t\t\t\tlet key = decodeURIComponent(parts.shift()!);\n\t\t\t\tlet value = parts.length > 0 ? parts.join('=') : null;\n\t\t\t\tif (value) {\n\t\t\t\t\tresult[key] = decodeURIComponent(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tstringify(input: StringMap) {\n\t\tlet encoded: string[] = [];\n\t\tfor (let key in input) {\n\t\t\tif (input.hasOwnProperty(key) && input[key]) {\n\t\t\t\tencoded.push(`${encodeURIComponent(key)}=${encodeURIComponent(input[key])}`);\n\t\t\t}\n\t\t}\n\t\treturn encoded.join('&');\n\t}\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/crypto-utils.ts",["190","191"],[],"/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/transports/websocket/ws-base.ts",["192"],[],"import { WebSocketConnection } from './connection-wrapper';\n\nexport abstract class BaseWebSocketService {\n    protected getHeaders = async () => {\n        const authHeaders: Record<string, string> = {};\n        authHeaders.Authorization = `Bearer yJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhMGJhYzYwNC0wZmE0LTQ0N2EtYTNkZS00ZGVmZjAyMDA4YzQiLCJqdGkiOiI3ZTViM2EzMS1mMmY3LTQwMjAtOTRkNS0xOTkxMTE5MWM0YzUiLCJleHAiOjE2OTA1OTk1MzEsInN1YiI6Ijc3MWEzNTFlLWIxODgtNGIzNC04YmQ5LTgzZWVjY2U3YWE5MyIsInNjb3BlcyI6WyJwcm9maWxlIiwiZW1haWwiXSwiZW1haWwiOiJkdWNwaHVvYy50OUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IsSQ4bupYyBQaMaw4bubYyIsImdpdmVuX25hbWUiOiLEkOG7qWMiLCJmYW1pbHlfbmFtZSI6IlBoxrDhu5tjIiwiaXNzIjoiaHR0cHM6Ly9pZC1kZXYtdjIubWlyYWlsYWJzLmNvIiwiYXpwIjoiYTBiYWM2MDQtMGZhNC00NDdhLWEzZGUtNGRlZmYwMjAwOGM0IiwiaWF0IjoxNjkwNTEzMTMxfQ.feJgykU5zMEsIyv_a_lBIWDYZmbYOWT1XMxI6RGpkEPWWRQb6FEbXTHgOu4ncneSR-_UUZrC6sFn1RYHCdvM-ahJ9U3lOKwrSSPl5iMXOqvEsrDjn_hK16fR0RQu8xBrU9hAMGmNzHXXJE2m41dGqy57kdqbDZhcWpg0s6IuIw7UburjKamF1G6yY_zFEgmkJdzzpPPS6DJQyh09Z3AKjiERz8IN2yC-geevdovA3i6omvIs4WlrwvC_wRVo5t-5I8SXzjHwDSZaG7j-HXlve1zNM9-qcWY3JjkXeol16nyzJ6JAIjdYX2eoWBS9eLDOQO4xKXdcN20crTT2Dy5T7Yc_u1g48e-0S-QDc0eGxe0gLqIihrf1MyoBd9Qvqns9PCC_dPsHDmNA5RqiaEFKXdBbJ9eXm8Kp_xZo1vp-_nyBFnbMSoSgSKxUP35V6IkHZdAQgZBiWykrktkwXr4mpQS4LL95DDp0bka-0LiQEHLnniGwsxkkAm4hcom28FGIKWRipJaW2I9Cn9OJ45u-1I5Jx9yz0a2oRvSTM7rY78liwbctAjBj-6SP2nLp8N2DGXBn98B7YVbbr0oDhJOlJHnNPiVVOAOg-f3sGIgbRWsqvVCX2TxaNtC4oU7Lr9k9tqF3V1FE4OqMngODdrMzOiM7iCzZ9NPO9DRpFJhWw5g`;\n\n        return authHeaders;\n    };\n\n    public abstract establish(): Promise<WebSocketConnection>;\n}\n","/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/transports/websocket/connection-wrapper.ts",[],[],{"ruleId":"193","severity":1,"message":"194","line":7,"column":11,"nodeType":"195","messageId":"196","endLine":7,"endColumn":26},{"ruleId":"197","severity":1,"message":"198","line":71,"column":15,"nodeType":"199","messageId":"200","endLine":71,"endColumn":37,"fix":"201"},{"ruleId":"197","severity":1,"message":"198","line":95,"column":15,"nodeType":"199","messageId":"200","endLine":95,"endColumn":28,"fix":"202"},{"ruleId":"197","severity":1,"message":"198","line":100,"column":17,"nodeType":"199","messageId":"200","endLine":100,"endColumn":52,"fix":"203"},{"ruleId":"197","severity":1,"message":"198","line":107,"column":17,"nodeType":"199","messageId":"200","endLine":107,"endColumn":52,"fix":"204"},{"ruleId":"205","severity":1,"message":"206","line":98,"column":1,"nodeType":"207","messageId":"208","endLine":98,"endColumn":3},{"ruleId":"205","severity":1,"message":"206","line":102,"column":1,"nodeType":"207","messageId":"208","endLine":102,"endColumn":3},{"ruleId":"209","severity":1,"message":"210","line":165,"column":28,"nodeType":"195","messageId":"211","endLine":165,"endColumn":37},{"ruleId":"193","severity":1,"message":"212","line":203,"column":23,"nodeType":"195","messageId":"196","endLine":203,"endColumn":40},{"ruleId":"193","severity":1,"message":"213","line":215,"column":27,"nodeType":"195","messageId":"196","endLine":215,"endColumn":33},{"ruleId":"193","severity":1,"message":"214","line":229,"column":15,"nodeType":"195","messageId":"196","endLine":229,"endColumn":25},{"ruleId":"193","severity":1,"message":"215","line":341,"column":24,"nodeType":"195","messageId":"196","endLine":341,"endColumn":40},{"ruleId":"193","severity":1,"message":"212","line":369,"column":29,"nodeType":"195","messageId":"196","endLine":369,"endColumn":58},{"ruleId":"193","severity":1,"message":"216","line":377,"column":39,"nodeType":"195","messageId":"196","endLine":377,"endColumn":57},{"ruleId":"193","severity":1,"message":"217","line":9,"column":7,"nodeType":"195","messageId":"196","endLine":9,"endColumn":14},{"ruleId":"193","severity":1,"message":"218","line":9,"column":18,"nodeType":"195","messageId":"196","endLine":17,"endColumn":2},{"ruleId":"219","severity":1,"message":"220","line":78,"column":18,"nodeType":"221","messageId":"222","endLine":78,"endColumn":59,"fix":"223"},{"ruleId":"219","severity":1,"message":"220","line":91,"column":60,"nodeType":"221","messageId":"222","endLine":91,"endColumn":72,"fix":"224"},{"ruleId":"193","severity":1,"message":"225","line":105,"column":32,"nodeType":"195","messageId":"196","endLine":105,"endColumn":39},{"ruleId":"219","severity":1,"message":"220","line":115,"column":23,"nodeType":"221","messageId":"222","endLine":115,"endColumn":51,"fix":"226"},{"ruleId":"219","severity":1,"message":"220","line":116,"column":16,"nodeType":"221","messageId":"222","endLine":116,"endColumn":69,"fix":"227"},{"ruleId":"193","severity":1,"message":"228","line":122,"column":20,"nodeType":"195","messageId":"196","endLine":122,"endColumn":28},{"ruleId":"219","severity":1,"message":"220","line":125,"column":18,"nodeType":"221","messageId":"222","endLine":125,"endColumn":31,"fix":"229"},{"ruleId":"209","severity":1,"message":"230","line":134,"column":35,"nodeType":"195","messageId":"211","endLine":134,"endColumn":40},{"ruleId":"193","severity":1,"message":"231","line":164,"column":27,"nodeType":"195","messageId":"196","endLine":164,"endColumn":41},{"ruleId":"219","severity":1,"message":"220","line":176,"column":23,"nodeType":"221","messageId":"222","endLine":176,"endColumn":30,"fix":"232"},{"ruleId":"219","severity":1,"message":"220","line":185,"column":23,"nodeType":"221","messageId":"222","endLine":185,"endColumn":30,"fix":"233"},{"ruleId":"219","severity":1,"message":"220","line":193,"column":30,"nodeType":"221","messageId":"222","endLine":193,"endColumn":54,"fix":"234"},{"ruleId":"219","severity":1,"message":"235","line":194,"column":8,"nodeType":"221","messageId":"236","endLine":194,"endColumn":74,"fix":"237"},{"ruleId":"193","severity":1,"message":"238","line":1,"column":10,"nodeType":"195","messageId":"196","endLine":1,"endColumn":14},{"ruleId":"193","severity":1,"message":"239","line":2,"column":10,"nodeType":"195","messageId":"196","endLine":2,"endColumn":25},{"ruleId":"193","severity":1,"message":"240","line":44,"column":22,"nodeType":"195","messageId":"196","endLine":44,"endColumn":35},{"ruleId":"193","severity":1,"message":"241","line":44,"column":37,"nodeType":"195","messageId":"196","endLine":44,"endColumn":51},{"ruleId":"193","severity":1,"message":"242","line":87,"column":85,"nodeType":"195","messageId":"196","endLine":87,"endColumn":97},{"ruleId":"243","severity":1,"message":"244","line":95,"column":51,"nodeType":"245","messageId":"246","endLine":95,"endColumn":58,"fix":"247"},{"ruleId":"243","severity":1,"message":"248","line":96,"column":50,"nodeType":"245","messageId":"246","endLine":96,"endColumn":56,"fix":"249"},{"ruleId":"193","severity":1,"message":"250","line":12,"column":6,"nodeType":"195","messageId":"196","endLine":12,"endColumn":19},{"ruleId":"251","severity":2,"message":"252","line":29,"column":22,"nodeType":"195","messageId":"253","endLine":29,"endColumn":29},{"ruleId":"251","severity":2,"message":"252","line":63,"column":22,"nodeType":"195","messageId":"253","endLine":63,"endColumn":29},{"ruleId":"193","severity":1,"message":"254","line":49,"column":47,"nodeType":"195","messageId":"196","endLine":49,"endColumn":53},{"ruleId":"193","severity":1,"message":"254","line":60,"column":38,"nodeType":"195","messageId":"196","endLine":60,"endColumn":44},{"ruleId":"193","severity":1,"message":"254","line":67,"column":38,"nodeType":"195","messageId":"196","endLine":67,"endColumn":44},{"ruleId":"193","severity":1,"message":"254","line":74,"column":38,"nodeType":"195","messageId":"196","endLine":74,"endColumn":44},{"ruleId":"255","message":"256","line":1,"column":19,"severity":1,"nodeType":null,"fix":"257","suggestions":"258","endLine":1,"endColumn":52},{"ruleId":"193","severity":1,"message":"259","line":3,"column":10,"nodeType":"195","messageId":"196","endLine":3,"endColumn":25},{"ruleId":"193","severity":1,"message":"212","line":41,"column":14,"nodeType":"195","messageId":"196","endLine":41,"endColumn":43},{"ruleId":"260","severity":1,"message":"261","line":98,"column":7,"nodeType":"262","messageId":"263","endLine":98,"endColumn":19},{"ruleId":"209","severity":1,"message":"264","line":98,"column":14,"nodeType":"195","messageId":"211","endLine":98,"endColumn":15},{"ruleId":"193","severity":1,"message":"265","line":21,"column":6,"nodeType":"195","messageId":"196","endLine":21,"endColumn":13},{"ruleId":"251","severity":2,"message":"266","line":10,"column":15,"nodeType":"195","messageId":"253","endLine":10,"endColumn":23},{"ruleId":"251","severity":2,"message":"266","line":15,"column":15,"nodeType":"195","messageId":"253","endLine":15,"endColumn":23},{"ruleId":"267","severity":1,"message":"268","line":34,"column":65,"nodeType":"245","messageId":"269","endLine":34,"endColumn":69,"fix":"270"},{"ruleId":"271","severity":1,"message":"272","line":75,"column":17,"nodeType":"273","messageId":"269","endLine":75,"endColumn":53},{"ruleId":"197","severity":1,"message":"198","line":6,"column":37,"nodeType":"199","messageId":"200","endLine":6,"endColumn":1312,"fix":"274"},"@typescript-eslint/no-unused-vars","'AuthClientProps' is defined but never used.","Identifier","unusedVar","quotes","Strings must use singlequote.","TemplateLiteral","wrongQuotes",{"range":"275","text":"276"},{"range":"277","text":"278"},{"range":"279","text":"280"},{"range":"281","text":"282"},"no-mixed-spaces-and-tabs","Mixed spaces and tabs.","Program","mixedSpacesAndTabs","no-shadow","'args' is already declared in the upper scope on line 157 column 36.","noShadow","'opts' is defined but never used. Allowed unused args must match /^_/u.","'e' is defined but never used. Allowed unused args must match /^_/u.","'namespaces' is assigned a value but never used.","'chains' is defined but never used. Allowed unused args must match /^_/u.","'projectId' is defined but never used. Allowed unused args must match /^_/u.","'getPeer' is assigned a value but never used.","'peer' is defined but never used. Allowed unused args must match /^_/u.","curly","Expected { after 'if' condition.","IfStatement","missingCurlyAfterCondition",{"range":"283","text":"284"},{"range":"285","text":"286"},"'request' is assigned a value but never used.",{"range":"287","text":"288"},{"range":"289","text":"290"},"'provider' is assigned a value but never used.",{"range":"291","text":"292"},"'chain' is already declared in the upper scope on line 134 column 9.","'optionalChains' is assigned a value but never used.",{"range":"293","text":"294"},{"range":"295","text":"294"},{"range":"296","text":"297"},"Expected { after 'else'.","missingCurlyAfter",{"range":"298","text":"299"},"'Mode' is defined but never used.","'AuthClientTypes' is defined but never used.","'topic' is defined but never used. Allowed unused args must match /^_/u.","'expiry' is defined but never used. Allowed unused args must match /^_/u.","'payload' is defined but never used. Allowed unused args must match /^_/u.","dot-notation","[\"state\"] is better written in dot notation.","Literal","useDot",{"range":"300","text":"301"},"[\"code\"] is better written in dot notation.",{"range":"302","text":"303"},"'BlockExplorer' is defined but never used.","no-undef","'Storage' is not defined.","undef","'reject' is defined but never used. Allowed unused args must match /^_/u.","eslint-comments/no-unused-disable","'@typescript-eslint/no-unused-vars' rule is disabled but never reported.",{"range":"304","text":"305"},["306"],"'AuthEngineTypes' is defined but never used.","no-catch-shadow","Value of 'e' may be overwritten in IE 8 and earlier.","CatchClause","mutable","'e' is already declared in the upper scope on line 55 column 33.","'RpcUrls' is defined but never used.","'Location' is not defined.","no-div-regex","A regular expression literal can be confused with '/='.","unexpected",{"range":"307","text":"308"},"no-bitwise","Unexpected use of '|'.","BinaryExpression",{"range":"309","text":"310"},[2054,2076],"'Initialized Listener'",[2772,2785],"'Initialized'",[2884,2919],"'AuthClient Initialization Success'",[3057,3092],"'AuthClient Initialization Failure'",[2141,2182],"{throw new Error('provider is required.');}",[2446,2458],"{throw error;}",[3011,3039],"{await this.createProvider();}",[3055,3108],"{await this.switchChain(chainId || this.chains[0].id);}",[3365,3378],"{return false;}",[4768,4775],"{return;}",[5069,5076],[5435,5459],"{this.emit('disconnect');}",[5467,5533],"{this.emit('change', { account: ethers.getAddress(accounts[0]!) });}",[3200,3209],".state",[3259,3267],".code",[0,54]," ",{"desc":"311","fix":"312"},[1292,1293],"[=]",[239,1514],"'Bearer yJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhMGJhYzYwNC0wZmE0LTQ0N2EtYTNkZS00ZGVmZjAyMDA4YzQiLCJqdGkiOiI3ZTViM2EzMS1mMmY3LTQwMjAtOTRkNS0xOTkxMTE5MWM0YzUiLCJleHAiOjE2OTA1OTk1MzEsInN1YiI6Ijc3MWEzNTFlLWIxODgtNGIzNC04YmQ5LTgzZWVjY2U3YWE5MyIsInNjb3BlcyI6WyJwcm9maWxlIiwiZW1haWwiXSwiZW1haWwiOiJkdWNwaHVvYy50OUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IsSQ4bupYyBQaMaw4bubYyIsImdpdmVuX25hbWUiOiLEkOG7qWMiLCJmYW1pbHlfbmFtZSI6IlBoxrDhu5tjIiwiaXNzIjoiaHR0cHM6Ly9pZC1kZXYtdjIubWlyYWlsYWJzLmNvIiwiYXpwIjoiYTBiYWM2MDQtMGZhNC00NDdhLWEzZGUtNGRlZmYwMjAwOGM0IiwiaWF0IjoxNjkwNTEzMTMxfQ.feJgykU5zMEsIyv_a_lBIWDYZmbYOWT1XMxI6RGpkEPWWRQb6FEbXTHgOu4ncneSR-_UUZrC6sFn1RYHCdvM-ahJ9U3lOKwrSSPl5iMXOqvEsrDjn_hK16fR0RQu8xBrU9hAMGmNzHXXJE2m41dGqy57kdqbDZhcWpg0s6IuIw7UburjKamF1G6yY_zFEgmkJdzzpPPS6DJQyh09Z3AKjiERz8IN2yC-geevdovA3i6omvIs4WlrwvC_wRVo5t-5I8SXzjHwDSZaG7j-HXlve1zNM9-qcWY3JjkXeol16nyzJ6JAIjdYX2eoWBS9eLDOQO4xKXdcN20crTT2Dy5T7Yc_u1g48e-0S-QDc0eGxe0gLqIihrf1MyoBd9Qvqns9PCC_dPsHDmNA5RqiaEFKXdBbJ9eXm8Kp_xZo1vp-_nyBFnbMSoSgSKxUP35V6IkHZdAQgZBiWykrktkwXr4mpQS4LL95DDp0bka-0LiQEHLnniGwsxkkAm4hcom28FGIKWRipJaW2I9Cn9OJ45u-1I5Jx9yz0a2oRvSTM7rY78liwbctAjBj-6SP2nLp8N2DGXBn98B7YVbbr0oDhJOlJHnNPiVVOAOg-f3sGIgbRWsqvVCX2TxaNtC4oU7Lr9k9tqF3V1FE4OqMngODdrMzOiM7iCzZ9NPO9DRpFJhWw5g'","Remove `eslint-disable` comment.",{"range":"304","text":"313"},""]