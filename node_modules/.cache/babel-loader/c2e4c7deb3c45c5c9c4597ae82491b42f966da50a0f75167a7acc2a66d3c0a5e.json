{"ast":null,"code":"import { AuthToken } from '../controllers/auth-token';\n\n// GENERATING CODE VERIFIER\nfunction dec2hex(dec) {\n  return ('0' + dec.toString(16)).substr(-2);\n}\nexport function generateCodeVerifier() {\n  var array = new Uint32Array(56 / 2);\n  window.crypto.getRandomValues(array);\n  return Array.from(array, dec2hex).join('');\n}\nexport const validateJwt = function (token) {\n  let buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  try {\n    const now = Math.round(Date.now() / 1000);\n    const parts = token.split('.');\n    const JWT_TOKEN_PART_LENGTH = 3;\n    if (parts.length !== JWT_TOKEN_PART_LENGTH) {\n      throw new Error('Not a valid JWT');\n    }\n\n    // Get middle part in payload string\n    const payload = JSON.parse(parts[1]);\n\n    // For offline_access refreshToken\n    if (!payload.exp) {\n      return true;\n    }\n    if (payload.exp && now >= payload.exp + buffer) {\n      throw new Error('Token expired');\n    }\n    return true;\n  } catch (e) {\n    console.log(e.message);\n  }\n  return false;\n};\nexport const createAuthHeaders = async () => {\n  const authHeaders = {};\n  const token = await AuthToken.get();\n  if (token) {\n    authHeaders.Authorization = \"Bearer \".concat(token === null || token === void 0 ? void 0 : token.access_token);\n  }\n  return authHeaders;\n};\nexport const getErrorMessage = e => {\n  console.log(e);\n  let message = '';\n  try {\n    var _e$networkError;\n    if (e.data && e.data.message) {\n      const error_message = e.data.message.replace('execution reverted: ', '').replace('execution reverted', '').trim();\n      if (error_message === '') {\n        message = 'Unknown Metamask response error!';\n      }\n      message = error_message;\n    } else if (e.reason) {\n      // prettier-ignore\n      const error_message = e.reason.replace('execution reverted: ', '').replace('execution reverted', '').trim();\n      if (error_message === '') {\n        message = 'Unknown Metamask response error!';\n      }\n      message = error_message;\n    } else if ((_e$networkError = e.networkError) !== null && _e$networkError !== void 0 && _e$networkError.result) {\n      var _e$networkError2;\n      message = (_e$networkError2 = e.networkError) === null || _e$networkError2 === void 0 ? void 0 : _e$networkError2.result.message;\n    } else if (e.error) {\n      var _e$error;\n      message = (_e$error = e.error) === null || _e$error === void 0 ? void 0 : _e$error.message;\n    } else {\n      message = e.message;\n    }\n    const regex = /(.*?)\\(/g;\n    if (message.match(regex)) {\n      const match = regex.exec(message);\n      if (match) {\n        message = match[1].trim();\n      }\n    }\n  } catch (e) {}\n  return message;\n};","map":{"version":3,"names":["AuthToken","dec2hex","dec","toString","substr","generateCodeVerifier","array","Uint32Array","window","crypto","getRandomValues","Array","from","join","validateJwt","token","buffer","arguments","length","undefined","now","Math","round","Date","parts","split","JWT_TOKEN_PART_LENGTH","Error","payload","JSON","parse","exp","e","console","log","message","createAuthHeaders","authHeaders","get","Authorization","concat","access_token","getErrorMessage","_e$networkError","data","error_message","replace","trim","reason","networkError","result","_e$networkError2","error","_e$error","regex","match","exec"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/utils/index.ts"],"sourcesContent":["import { AuthToken } from '../controllers/auth-token';\n\n// GENERATING CODE VERIFIER\nfunction dec2hex(dec: any) {\n    return ('0' + dec.toString(16)).substr(-2);\n}\n\nexport function generateCodeVerifier() {\n    var array = new Uint32Array(56 / 2);\n    window.crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join('');\n}\n\nexport const validateJwt = (token: string, buffer: number = 0) => {\n    try {\n        const now = Math.round(Date.now() / 1000);\n        const parts = token.split('.');\n\n        const JWT_TOKEN_PART_LENGTH = 3;\n\n        if (parts.length !== JWT_TOKEN_PART_LENGTH) {\n            throw new Error('Not a valid JWT');\n        }\n\n        // Get middle part in payload string\n        const payload = JSON.parse(parts[1]);\n\n        // For offline_access refreshToken\n        if (!payload.exp) {\n            return true;\n        }\n\n        if (payload.exp && now >= payload.exp + buffer) {\n            throw new Error('Token expired');\n        }\n\n        return true;\n    } catch (e) {\n        console.log(e.message);\n    }\n    return false;\n};\n\nexport const createAuthHeaders = async () => {\n    const authHeaders: Record<string, string> = {};\n    const token = await AuthToken.get();\n\n    if (token) {\n        authHeaders.Authorization = `Bearer ${token?.access_token}`;\n    }\n\n    return authHeaders;\n};\n\nexport const getErrorMessage = (e: any): string => {\n    console.log(e);\n    let message: string = '';\n    try {\n        if (e.data && e.data.message) {\n            const error_message = e.data.message\n                .replace('execution reverted: ', '')\n                .replace('execution reverted', '')\n                .trim();\n\n            if (error_message === '') {\n                message = 'Unknown Metamask response error!';\n            }\n\n            message = error_message;\n        } else if (e.reason) {\n            // prettier-ignore\n            const error_message = e.reason\n\t\t\t\t.replace('execution reverted: ', '')\n\t\t\t\t.replace('execution reverted', '')\n\t\t\t\t.trim();\n\n            if (error_message === '') {\n                message = 'Unknown Metamask response error!';\n            }\n\n            message = error_message;\n        } else if (e.networkError?.result) {\n            message = e.networkError?.result.message;\n        } else if (e.error) {\n            message = e.error?.message;\n        } else {\n            message = e.message;\n        }\n\n        const regex = /(.*?)\\(/g;\n\n        if (message.match(regex)) {\n            const match = regex.exec(message);\n            if (match) {\n                message = match[1].trim();\n            }\n        }\n    } catch (e) {}\n\n    return message;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}