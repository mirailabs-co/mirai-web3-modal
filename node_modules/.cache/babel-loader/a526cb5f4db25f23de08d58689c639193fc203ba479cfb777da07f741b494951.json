{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { env } from '../constants';\nimport { IAuthEngine } from '../types';\nimport { DefaultCrypto } from '../utils/crypto-utils';\nimport { BasicQueryStringUtils } from '../utils/query-utils';\nimport { LocalStorageBackend } from '../utils/storage';\nclass AuthEngine extends IAuthEngine {\n  constructor(client) {\n    super(client);\n    _defineProperty(this, \"name\", 'MiraiAuth');\n    _defineProperty(this, \"initialized\", false);\n    _defineProperty(this, \"storageBackend\", void 0);\n    _defineProperty(this, \"utils\", void 0);\n    _defineProperty(this, \"crypto\", void 0);\n    _defineProperty(this, \"getApiUrl\", () => {\n      if (this.client.mode === 'development') {\n        return env.MIRAI_ID_API_URL_DEV;\n      }\n      return env.MIRAI_ID_API_URL_PROD;\n    });\n    // PRIVATE\n    _defineProperty(this, \"performAuthorizationRequest\", async request => {\n      const handle = this.crypto.generateRandom(10);\n      console.log('making handle', handle);\n\n      // before you make request, persist all request related data in local storage.\n      const persisted = Promise.all([this.storageBackend.setItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY, handle),\n      // Calling toJson() adds in the code & challenge when possible\n      this.storageBackend.setItem(this._authorizationRequestKey(handle), JSON.stringify(request))]);\n      persisted.then(async () => {\n        try {\n          // make the redirect request\n          console.log('Making a request to ', \"\".concat(this.getApiUrl(), \"/api/auth/login?client_id=\").concat(this.client.clientId, \"&redirect_uri=\").concat(request.redirect_uri, \"&code_challenge_method=\").concat(request.code_challenge_method));\n          window.location.assign(\"\".concat(this.getApiUrl(), \"/api/auth/login?client_id=\").concat(this.client.clientId, \"&redirect_uri=\").concat(request.redirect_uri, \"&code_challenge_method=\").concat(request.code_challenge_method));\n        } catch (e) {}\n      });\n    });\n    /** key for authorization request. */\n    _defineProperty(this, \"_authorizationRequestKey\", handle => {\n      return \"\".concat(handle, \"_appauth_authorization_request\");\n    });\n    /** key in local storage which represents the current authorization request. */\n    _defineProperty(this, \"_AUTHORIZATION_REQUEST_HANDLE_KEY\", 'appauth_current_authorization_request');\n    this.storageBackend = new LocalStorageBackend();\n    this.utils = new BasicQueryStringUtils();\n    this.crypto = new DefaultCrypto();\n  }\n  init() {\n    if (!this.initialized) {\n      this.initialized = true;\n    }\n  }\n  async registerOnAuthResponse() {\n    return await this.onAuthResponse();\n  }\n  async request(params) {\n    await this.performAuthorizationRequest(params);\n  }\n  setExpiry(topic, expiry) {\n    throw new Error('Method not implemented.');\n  }\n  onAuthRequest() {\n    throw new Error('Method not implemented.');\n  }\n  onAuthResponse() {\n    this.storageBackend.getItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY).then(handle => {\n      if (handle) {\n        return this.storageBackend.getItem(this._authorizationRequestKey(handle)).then(payload => {\n          // cleanup state\n          return Promise.all([\n            // this.storageBackend.removeItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY),\n            // this.storageBackend.removeItem(this._authorizationRequestKey(handle)),\n          ]).then(() => {\n            console.log('Delivering authorization response');\n            let queryParams = this.utils.parse(window.location, false /* use hash */);\n            let state = queryParams['state'];\n            let code = queryParams['code'];\n            console.log(\"we're received code=\".concat(code, \" and state=\").concat(state));\n            if (code && state) {\n              this.client.emit('auth_response', {\n                params: {\n                  code,\n                  state\n                }\n              });\n            }\n          });\n        });\n      }\n    });\n  }\n}\nexport default AuthEngine;","map":{"version":3,"names":["env","IAuthEngine","DefaultCrypto","BasicQueryStringUtils","LocalStorageBackend","AuthEngine","constructor","client","_defineProperty","mode","MIRAI_ID_API_URL_DEV","MIRAI_ID_API_URL_PROD","request","handle","crypto","generateRandom","console","log","persisted","Promise","all","storageBackend","setItem","_AUTHORIZATION_REQUEST_HANDLE_KEY","_authorizationRequestKey","JSON","stringify","then","concat","getApiUrl","clientId","redirect_uri","code_challenge_method","window","location","assign","e","utils","init","initialized","registerOnAuthResponse","onAuthResponse","params","performAuthorizationRequest","setExpiry","topic","expiry","Error","onAuthRequest","getItem","payload","queryParams","parse","state","code","emit"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/auth-client/controllers/engine.ts"],"sourcesContent":["import { Mode, env } from '../constants';\nimport { AuthClientTypes, AuthEngineTypes, IAuthEngine } from '../types';\nimport { DefaultCrypto } from '../utils/crypto-utils';\nimport { BasicQueryStringUtils } from '../utils/query-utils';\nimport { LocalStorageBackend, StorageBackend } from '../utils/storage';\n\nclass AuthEngine extends IAuthEngine {\n\tpublic name: string = 'MiraiAuth';\n\tprivate initialized = false;\n\n\tprivate storageBackend: StorageBackend;\n\tprivate utils: BasicQueryStringUtils;\n\tprivate crypto: DefaultCrypto;\n\n\tconstructor(client: IAuthEngine['client']) {\n\t\tsuper(client);\n\t\tthis.storageBackend = new LocalStorageBackend();\n\t\tthis.utils = new BasicQueryStringUtils();\n\t\tthis.crypto = new DefaultCrypto();\n\t}\n\n\tpublic init(): void {\n\t\tif (!this.initialized) {\n\t\t\tthis.initialized = true;\n\t\t}\n\t}\n\n\tpublic async registerOnAuthResponse(): Promise<void> {\n\t\treturn await this.onAuthResponse();\n\t}\n\n\tpublic getApiUrl = () => {\n\t\tif (this.client.mode === 'development') {\n\t\t\treturn env.MIRAI_ID_API_URL_DEV;\n\t\t}\n\n\t\treturn env.MIRAI_ID_API_URL_PROD;\n\t};\n\n\tpublic async request(params: AuthEngineTypes.RequestParams): Promise<void> {\n\t\tawait this.performAuthorizationRequest(params);\n\t}\n\n\tprotected setExpiry(topic: string, expiry: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tprotected onAuthRequest(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\t// PRIVATE\n\tprivate performAuthorizationRequest = async (request: AuthEngineTypes.RequestParams): Promise<any> => {\n\t\tconst handle = this.crypto.generateRandom(10);\n\n\t\tconsole.log('making handle', handle);\n\n\t\t// before you make request, persist all request related data in local storage.\n\t\tconst persisted = Promise.all([\n\t\t\tthis.storageBackend.setItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY, handle),\n\t\t\t// Calling toJson() adds in the code & challenge when possible\n\t\t\tthis.storageBackend.setItem(this._authorizationRequestKey(handle), JSON.stringify(request)),\n\t\t]);\n\n\t\tpersisted.then(async () => {\n\t\t\ttry {\n\t\t\t\t// make the redirect request\n\t\t\t\tconsole.log(\n\t\t\t\t\t'Making a request to ',\n\t\t\t\t\t`${this.getApiUrl()}/api/auth/login?client_id=${this.client.clientId}&redirect_uri=${\n\t\t\t\t\t\trequest.redirect_uri\n\t\t\t\t\t}&code_challenge_method=${request.code_challenge_method}`,\n\t\t\t\t);\n\n\t\t\t\twindow.location.assign(\n\t\t\t\t\t`${this.getApiUrl()}/api/auth/login?client_id=${this.client.clientId}&redirect_uri=${\n\t\t\t\t\t\trequest.redirect_uri\n\t\t\t\t\t}&code_challenge_method=${request.code_challenge_method}`,\n\t\t\t\t);\n\t\t\t} catch (e) {}\n\t\t});\n\t};\n\n\tprotected onAuthResponse(): void {\n\t\tthis.storageBackend.getItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY).then((handle: any) => {\n\t\t\tif (handle) {\n\t\t\t\treturn this.storageBackend.getItem(this._authorizationRequestKey(handle)).then((payload: any) => {\n\t\t\t\t\t// cleanup state\n\t\t\t\t\treturn Promise.all([\n\t\t\t\t\t\t// this.storageBackend.removeItem(this._AUTHORIZATION_REQUEST_HANDLE_KEY),\n\t\t\t\t\t\t// this.storageBackend.removeItem(this._authorizationRequestKey(handle)),\n\t\t\t\t\t]).then(() => {\n\t\t\t\t\t\tconsole.log('Delivering authorization response');\n\t\t\t\t\t\tlet queryParams = this.utils.parse(window.location, false /* use hash */);\n\t\t\t\t\t\tlet state: string | undefined = queryParams['state'];\n\t\t\t\t\t\tlet code: string | undefined = queryParams['code'];\n\n\t\t\t\t\t\tconsole.log(`we're received code=${code} and state=${state}`);\n\n\t\t\t\t\t\tif (code && state) {\n\t\t\t\t\t\t\tthis.client.emit('auth_response', { params: { code, state } });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/** key for authorization request. */\n\t_authorizationRequestKey = (handle: string) => {\n\t\treturn `${handle}_appauth_authorization_request`;\n\t};\n\n\t/** key in local storage which represents the current authorization request. */\n\t_AUTHORIZATION_REQUEST_HANDLE_KEY = 'appauth_current_authorization_request';\n}\n\nexport default AuthEngine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}