{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { MiraiConnection } from '../connection/mirai-connection';\nimport { Core } from './core';\nimport { ServiceQueryRequest } from '../../shared/utils/service-query-request';\nimport { MiraiIDAPI } from '../transports/http/http-miraiid';\nimport { NoAccessToken, SDKError } from '../errors';\nconst MIRAI_SIGN_PAGE = 'https://mirai-app-sdk-demo.vercel.app/sign';\nexport class MiraiCore extends Core {\n  // onOpenConnectionModal: (connnection: Connection, url: string) => Promise<void>;\n  // onCloseConnectionModal: (connnection: Connection) => Promise<void>;\n  constructor(opts) {\n    super(opts);\n    _defineProperty(this, \"chains\", void 0);\n    _defineProperty(this, \"namespace\", void 0);\n    _defineProperty(this, \"connections\", void 0);\n    this.chains = opts.chains;\n    this.namespace = opts.chainNameSpace;\n    // this.onOpenConnectionModal = opts.onOpenConnectionModal;\n    // this.onCloseConnectionModal = opts.onCloseConnectionModal;\n  }\n\n  static async init(opts) {\n    const core = new MiraiCore(opts);\n    await core.initialize();\n    return core;\n  }\n  async connect(_ref) {\n    let {\n      accessToken\n    } = _ref;\n    if (!accessToken) {\n      throw new NoAccessToken(SDKError.NoConnection, 'Not found access token. Pleases connect MiraiID first');\n    }\n    const newConnection = await MiraiConnection.init();\n    newConnection.emit('chains', this.chains);\n    newConnection.emit('namespace', this.namespace);\n    this.emit('connecting');\n    const isConnected = await newConnection.connect({\n      accessToken\n    });\n    if (isConnected) {\n      newConnection.on('disconnected', async () => {\n        // typeof this.onCloseConnectionModal === 'function' && (await this.onCloseConnectionModal(newConnection));\n\n        this.emit('disconnected', this.connections[newConnection.topicId]);\n        this.connections[newConnection.topicId] = null;\n      });\n      this.connections[newConnection.topicId] = newConnection;\n      this.emit('new_connection', {\n        topicId: newConnection.topicId\n      });\n    } else {\n      throw new Error('Not connection');\n    }\n    return newConnection;\n  }\n  async getConnection(_ref2) {\n    let {\n      topicId\n    } = _ref2;\n    return this.connections[topicId];\n  }\n  async showConnectionModal(connection) {\n    return new Promise(async (resolve, reject) => {\n      const topicId = connection.topicId;\n      connection.on('display_uri', async uri => {\n        console.log('uri', uri);\n        if (!uri) {\n          reject(false);\n        }\n        // FIX BUG ADD_PARAM\n        const url = new URL(MIRAI_SIGN_PAGE);\n        const __serviceQuery = new ServiceQueryRequest(url.href, url.searchParams.toString());\n        __serviceQuery.addParam('topicId', topicId);\n        __serviceQuery.addParam('wc_uri', uri);\n        if (uri) {\n          console.log(__serviceQuery.toUri());\n          // typeof this.onOpenConnectionModal === 'function' &&\n          // \t(await this.onOpenConnectionModal(connection, __serviceQuery.toUri()));\n\n          return resolve({\n            connection,\n            uri\n          });\n        }\n        return resolve(null);\n      });\n      const {\n        namespace,\n        chains,\n        accessToken\n      } = connection;\n\n      // We're get pairing uri\n      await MiraiIDAPI.INSTANCE.getPairingUri(namespace, chains, accessToken);\n    });\n  }\n  async disconnect(connection) {\n    if (connection) {\n      await connection.disconnect();\n    }\n  }\n  disconnectAll() {\n    throw new Error('Method not implemented.');\n  }\n\n  // PRIVATE\n  async initialize() {\n    try {\n      // FOR INITIALIZE SOMETHING\n\n      this.connections = {};\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}","map":{"version":3,"names":["MiraiConnection","Core","ServiceQueryRequest","MiraiIDAPI","NoAccessToken","SDKError","MIRAI_SIGN_PAGE","MiraiCore","constructor","opts","_defineProperty","chains","namespace","chainNameSpace","init","core","initialize","connect","_ref","accessToken","NoConnection","newConnection","emit","isConnected","on","connections","topicId","Error","getConnection","_ref2","showConnectionModal","connection","Promise","resolve","reject","uri","console","log","url","URL","__serviceQuery","href","searchParams","toString","addParam","toUri","INSTANCE","getPairingUri","disconnect","disconnectAll","e","error"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/cores/mirai-core.ts"],"sourcesContent":["import { MiraiConnection } from '../connection/mirai-connection';\nimport { Core, ICore } from './core';\nimport { Connection } from '../connection/connection';\nimport { ServiceQueryRequest } from '../../shared/utils/service-query-request';\nimport { MiraiIDAPI } from '../transports/http/http-miraiid';\nimport { NoAccessToken, SDKError } from '../errors';\n\nconst MIRAI_SIGN_PAGE: string = 'https://mirai-app-sdk-demo.vercel.app/sign';\n\ntype TShowModal = {\n\tconnection: Connection;\n\turi: string;\n};\n\nexport class MiraiCore extends Core {\n\tchains: string[];\n\tnamespace: string;\n\tconnections: Record<string, MiraiConnection>;\n\n\t// onOpenConnectionModal: (connnection: Connection, url: string) => Promise<void>;\n\t// onCloseConnectionModal: (connnection: Connection) => Promise<void>;\n\n\tconstructor(opts?: ICore) {\n\t\tsuper(opts);\n\n\t\tthis.chains = opts.chains;\n\t\tthis.namespace = opts.chainNameSpace;\n\t\t// this.onOpenConnectionModal = opts.onOpenConnectionModal;\n\t\t// this.onCloseConnectionModal = opts.onCloseConnectionModal;\n\t}\n\n\tstatic async init(opts?: ICore) {\n\t\tconst core = new MiraiCore(opts);\n\t\tawait core.initialize();\n\n\t\treturn core;\n\t}\n\n\tpublic async connect({ accessToken }: { accessToken: string }) {\n\t\tif (!accessToken) {\n\t\t\tthrow new NoAccessToken(SDKError.NoConnection, 'Not found access token. Pleases connect MiraiID first');\n\t\t}\n\n\t\tconst newConnection = await MiraiConnection.init();\n\n\t\tnewConnection.emit('chains', this.chains);\n\t\tnewConnection.emit('namespace', this.namespace);\n\t\tthis.emit('connecting');\n\t\tconst isConnected = await newConnection.connect({ accessToken });\n\n\t\tif (isConnected) {\n\t\t\tnewConnection.on('disconnected', async () => {\n\t\t\t\t// typeof this.onCloseConnectionModal === 'function' && (await this.onCloseConnectionModal(newConnection));\n\n\t\t\t\tthis.emit('disconnected', this.connections[newConnection.topicId]);\n\n\t\t\t\tthis.connections[newConnection.topicId] = null;\n\t\t\t});\n\n\t\t\tthis.connections[newConnection.topicId] = newConnection;\n\t\t\tthis.emit('new_connection', { topicId: newConnection.topicId });\n\t\t} else {\n\t\t\tthrow new Error('Not connection');\n\t\t}\n\n\t\treturn newConnection;\n\t}\n\n\tpublic async getConnection({ topicId }: { topicId: string }): Promise<Connection> {\n\t\treturn this.connections[topicId];\n\t}\n\n\tpublic async showConnectionModal(connection: MiraiConnection): Promise<TShowModal> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst topicId = connection.topicId;\n\n\t\t\tconnection.on('display_uri', async (uri: string) => {\n\t\t\t\tconsole.log('uri', uri);\n\t\t\t\tif (!uri) {\n\t\t\t\t\treject(false);\n\t\t\t\t}\n\t\t\t\t// FIX BUG ADD_PARAM\n\t\t\t\tconst url = new URL(MIRAI_SIGN_PAGE);\n\t\t\t\tconst __serviceQuery = new ServiceQueryRequest(url.href, url.searchParams.toString());\n\n\t\t\t\t__serviceQuery.addParam('topicId', topicId);\n\t\t\t\t__serviceQuery.addParam('wc_uri', uri);\n\n\t\t\t\tif (uri) {\n\t\t\t\t\tconsole.log(__serviceQuery.toUri());\n\t\t\t\t\t// typeof this.onOpenConnectionModal === 'function' &&\n\t\t\t\t\t// \t(await this.onOpenConnectionModal(connection, __serviceQuery.toUri()));\n\n\t\t\t\t\treturn resolve({ connection, uri });\n\t\t\t\t}\n\t\t\t\treturn resolve(null);\n\t\t\t});\n\n\t\t\tconst { namespace, chains, accessToken } = connection;\n\n\t\t\t// We're get pairing uri\n\t\t\tawait MiraiIDAPI.INSTANCE.getPairingUri(namespace, chains, accessToken);\n\t\t});\n\t}\n\n\tpublic async disconnect(connection: Connection): Promise<void> {\n\t\tif (connection) {\n\t\t\tawait connection.disconnect();\n\t\t}\n\t}\n\n\tpublic disconnectAll(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\t// PRIVATE\n\tasync initialize() {\n\t\ttry {\n\t\t\t// FOR INITIALIZE SOMETHING\n\n\t\t\tthis.connections = {};\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}