{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { EventEmitter } from 'events';\nimport { miraiTestnet } from '../../constants/chains';\nimport { NotFoundMiraiConnectionError } from '../errors/NoConnectionError';\nimport { MiraiIDAPI } from '../transports/http/http-miraiid';\nexport function getEthereumChainId(chains) {\n  return chains[0].split(':')[1];\n}\nexport function toHexChainId(chainId) {\n  return chainId;\n}\n\n// helper type to force setting at least one value in an array\n\nexport class MiraiProvider {\n  constructor() {\n    _defineProperty(this, \"emitter\", new EventEmitter());\n    _defineProperty(this, \"accounts\", []);\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"chainId\", \"0x\".concat(miraiTestnet.id.toString(16)));\n    _defineProperty(this, \"on\", (event, listener) => {\n      this.emitter.on(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"once\", (event, listener) => {\n      this.emitter.once(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"removeListener\", (event, listener) => {\n      this.emitter.removeListener(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"off\", (event, listener) => {\n      this.emitter.off(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"parseAccount\", payload => {\n      return this.parseAccountId(payload).address;\n    });\n  } // assigned during initialize\n  // this._signer = new SignerWebSocketService();\n\n  static async init(opts) {\n    const provider = new MiraiProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n\n  // public async request<T = unknown>(args: RequestArguments<RpcMethod>): Promise<T> {\n  // \treturn new Promise(async (resolve, reject) => {\n  // \t\tconst socket = await this.connection.ws.establish(true);\n\n  // \t\tsocket.on('exception', (args: any) => {\n  // \t\t\tsocket.disconnect();\n  // \t\t\treject(new Error(JSON.stringify(args)));\n  // \t\t});\n\n  // \t\tsocket.on('connect', () => {\n  // \t\t\tsocket\n  // \t\t\t\t.getSocket()\n  // \t\t\t\t.emit(this.connection.topicId, args, (data: T & { code: number; message: string }) => {\n  // \t\t\t\t\tif (data.code) {\n  // \t\t\t\t\t\treject(new Error(data.message));\n  // \t\t\t\t\t}\n\n  // \t\t\t\t\tresolve(data);\n  // \t\t\t\t});\n  // \t\t});\n\n  // \t\tsocket.on('connect_error', () => {\n  // \t\t\treject(new Error('Connection error'));\n  // \t\t});\n\n  // \t\tsocket.connect();\n  // \t});\n  // }\n  async request(args) {\n    return await MiraiIDAPI.INSTANCE.sendRequest(this.connection.wcTopicId, {\n      chainId: \"\".concat(this.connection.namespace, \":\").concat(Number(parseInt(this.chainId, 16))),\n      request: args\n    });\n  }\n  async enable() {\n    const accounts = await this.request({\n      method: 'eth_requestAccounts'\n    });\n    return accounts;\n  }\n  async getChainId() {\n    const chain = await this.request({\n      method: 'eth_chainId'\n    });\n    return chain;\n  }\n  async connect(opts) {\n    if (!this.connection.isConnected()) {\n      throw new Error('Connection not initialized. Call MiraiConnection.init() first');\n    }\n    this.emitter.emit('connect', {\n      chainId: this.chainId\n    });\n  }\n  get isWalletConnect() {\n    return true;\n  }\n  switchEthereumChain(chainId) {\n    this.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{\n        chainId: chainId.toString(16)\n      }]\n    });\n  }\n  parseChainId(chainId) {\n    return Number(chainId.split(':')[1]);\n  }\n  setChainIds(chains) {\n    this.emitter.emit('chainChanged', this.chainId);\n    this.persist();\n  }\n  setChainId(chain) {\n    this.switchEthereumChain(chain);\n  }\n  parseAccountId(account) {\n    const [namespace, reference, address] = account.split(':');\n    const chainId = \"\".concat(namespace, \":\").concat(reference);\n    return {\n      chainId,\n      address\n    };\n  }\n  setAccounts(accounts) {\n    this.accounts = accounts.map(x => this.parseAccountId(x).address);\n    this.emitter.emit('accountsChanged', this.accounts);\n  }\n  async initialize(opts) {\n    this.connection = opts.connection;\n    if (!this.connection) {\n      throw new NotFoundMiraiConnectionError('No mirai connection found');\n    }\n    await this.registerEventListener();\n  }\n  async registerEventListener() {\n    return new Promise(async (resolve, reject) => {\n      const socket = await this.connection.ws.establish(true);\n      socket.on('exception', args => {\n        socket.disconnect();\n        reject(new Error(JSON.stringify(args)));\n      });\n      socket.on('connect', args => {\n        resolve();\n      });\n      socket.on(this.connection.topicId, payload => {\n        const {\n          params\n        } = payload;\n        if (params && params !== undefined) {\n          const {\n            event\n          } = params;\n          if (event.name === 'accountsChanged') {\n            this.accounts = this.parseAccounts(event.data);\n            this.emitter.emit('accountsChanged', this.accounts);\n          } else if (event.name === 'chainChanged') {\n            this.setChainId(event.data);\n          } else {\n            this.emitter.emit(event.name, event.data);\n          }\n        }\n      });\n      socket.on('connect_error', () => {\n        reject(new Error('Connection error'));\n      });\n      socket.connect();\n    });\n  }\n  reset() {\n    this.chainId = \"0x\".concat(miraiTestnet.id.toString(16));\n    this.accounts = [];\n  }\n  persist() {}\n  parseAccounts(payload) {\n    if (typeof payload === 'string' || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map(account => this.parseAccount(account));\n  }\n}","map":{"version":3,"names":["EventEmitter","miraiTestnet","NotFoundMiraiConnectionError","MiraiIDAPI","getEthereumChainId","chains","split","toHexChainId","chainId","MiraiProvider","constructor","_defineProperty","concat","id","toString","event","listener","emitter","on","once","removeListener","off","payload","parseAccountId","address","init","opts","provider","initialize","request","args","INSTANCE","sendRequest","connection","wcTopicId","namespace","Number","parseInt","enable","accounts","method","getChainId","chain","connect","isConnected","Error","emit","isWalletConnect","switchEthereumChain","params","parseChainId","setChainIds","persist","setChainId","account","reference","setAccounts","map","x","registerEventListener","Promise","resolve","reject","socket","ws","establish","disconnect","JSON","stringify","topicId","undefined","name","parseAccounts","data","reset","String","parseAccount"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/providers/mirai-provider.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport {\n\tIEthereumProvider as IProvider,\n\tIEthereumProviderEvents,\n\tProviderAccounts,\n\tRequestArguments,\n\tProviderChainId,\n\tRpcMethod,\n\tIProviderEvents,\n} from './types';\nimport { Connection } from '../connection/connection';\nimport { miraiTestnet } from '../../constants/chains';\nimport { NotFoundMiraiConnectionError } from '../errors/NoConnectionError';\nimport { MiraiIDAPI } from '../transports/http/http-miraiid';\n\nexport type RpcEvent = 'accountsChanged' | 'chainChanged' | 'message' | 'disconnect' | 'connect';\n\nexport interface EthereumRpcMap {\n\t[chainId: string]: string;\n}\n\nexport interface SessionEvent {\n\tevent: { name: string; data: any };\n\tchainId: string;\n}\n\nexport interface ConnectOps {\n\tchains?: string[];\n\toptionalChains?: string[];\n\trpcMap?: EthereumRpcMap;\n\tpairingTopic?: string;\n\tchainId?: string;\n}\n\nexport interface IEthereumProvider extends IProvider {\n\tconnect(opts?: ConnectOps | undefined): Promise<void>;\n}\n\nexport function getEthereumChainId(chains: string[]): string {\n\treturn chains[0].split(':')[1];\n}\n\nexport function toHexChainId(chainId: string): string {\n\treturn chainId;\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n\t0: T;\n} & Array<T>;\n\nexport type EthereumProviderOptions = {\n\tconnection?: Connection;\n};\n\nexport type WalletConnectSession = {\n\ttopic: string;\n\texpiry: number;\n\tacknowledged: boolean;\n\tpairingTopic: string;\n\tcontroller: string;\n\tpeer: {\n\t\tpublicKey: string;\n\t\tmetadata: {\n\t\t\tname: string;\n\t\t\tdescription: string;\n\t\t\turl: string;\n\t\t\ticons: [];\n\t\t};\n\t};\n\tnamespaces?: {\n\t\t'eip155': {\n\t\t\taccounts: string[];\n\t\t\tevents: string[];\n\t\t};\n\t};\n};\n\nexport class MiraiProvider implements IEthereumProvider {\n\tpublic emitter = new EventEmitter();\n\tpublic accounts: string[] = [];\n\tprivate connection: Connection;\n\tpublic chainId = `0x${miraiTestnet.id.toString(16)}`;\n\n\tconstructor() {\n\t\t// assigned during initialize\n\t\t// this._signer = new SignerWebSocketService();\n\t}\n\n\tstatic async init(opts: EthereumProviderOptions): Promise<MiraiProvider> {\n\t\tconst provider = new MiraiProvider();\n\t\tawait provider.initialize(opts);\n\n\t\treturn provider;\n\t}\n\n\t// public async request<T = unknown>(args: RequestArguments<RpcMethod>): Promise<T> {\n\t// \treturn new Promise(async (resolve, reject) => {\n\t// \t\tconst socket = await this.connection.ws.establish(true);\n\n\t// \t\tsocket.on('exception', (args: any) => {\n\t// \t\t\tsocket.disconnect();\n\t// \t\t\treject(new Error(JSON.stringify(args)));\n\t// \t\t});\n\n\t// \t\tsocket.on('connect', () => {\n\t// \t\t\tsocket\n\t// \t\t\t\t.getSocket()\n\t// \t\t\t\t.emit(this.connection.topicId, args, (data: T & { code: number; message: string }) => {\n\t// \t\t\t\t\tif (data.code) {\n\t// \t\t\t\t\t\treject(new Error(data.message));\n\t// \t\t\t\t\t}\n\n\t// \t\t\t\t\tresolve(data);\n\t// \t\t\t\t});\n\t// \t\t});\n\n\t// \t\tsocket.on('connect_error', () => {\n\t// \t\t\treject(new Error('Connection error'));\n\t// \t\t});\n\n\t// \t\tsocket.connect();\n\t// \t});\n\t// }\n\tpublic async request<T = unknown>(args: RequestArguments<RpcMethod>): Promise<T> {\n\t\treturn await MiraiIDAPI.INSTANCE.sendRequest(this.connection.wcTopicId, {\n\t\t\tchainId: `${this.connection.namespace}:${Number(parseInt(this.chainId, 16))}`,\n\t\t\trequest: args,\n\t\t});\n\t}\n\n\tpublic async enable(): Promise<ProviderAccounts> {\n\t\tconst accounts = await this.request<ProviderAccounts>({ method: 'eth_requestAccounts' });\n\t\treturn accounts as ProviderAccounts;\n\t}\n\n\tpublic async getChainId(): Promise<ProviderChainId> {\n\t\tconst chain = await this.request({ method: 'eth_chainId' });\n\n\t\treturn chain as ProviderChainId;\n\t}\n\n\tpublic async connect(opts?: ConnectOps): Promise<void> {\n\t\tif (!this.connection.isConnected()) {\n\t\t\tthrow new Error('Connection not initialized. Call MiraiConnection.init() first');\n\t\t}\n\n\t\tthis.emitter.emit('connect', { chainId: this.chainId });\n\t}\n\n\tpublic on: IEthereumProviderEvents['on'] = (event, listener) => {\n\t\tthis.emitter.on(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic once: IEthereumProviderEvents['once'] = (event, listener) => {\n\t\tthis.emitter.once(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic removeListener: IEthereumProviderEvents['removeListener'] = (event, listener) => {\n\t\tthis.emitter.removeListener(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic off: IEthereumProviderEvents['off'] = (event, listener) => {\n\t\tthis.emitter.off(event, listener);\n\t\treturn this;\n\t};\n\n\tget isWalletConnect() {\n\t\treturn true;\n\t}\n\n\tprotected switchEthereumChain(chainId: number): void {\n\t\tthis.request({\n\t\t\tmethod: 'wallet_switchEthereumChain',\n\t\t\tparams: [{ chainId: chainId.toString(16) }],\n\t\t});\n\t}\n\n\tprotected parseChainId(chainId: string): number {\n\t\treturn Number(chainId.split(':')[1]);\n\t}\n\n\tprotected setChainIds(chains: string[]) {\n\t\tthis.emitter.emit('chainChanged', this.chainId);\n\t\tthis.persist();\n\t}\n\n\tprotected setChainId(chain: number) {\n\t\tthis.switchEthereumChain(chain);\n\t}\n\n\tprotected parseAccountId(account: string): { chainId: string; address: string } {\n\t\tconst [namespace, reference, address] = account.split(':');\n\t\tconst chainId = `${namespace}:${reference}`;\n\t\treturn { chainId, address };\n\t}\n\n\tprotected setAccounts(accounts: string[]) {\n\t\tthis.accounts = accounts.map((x) => this.parseAccountId(x).address);\n\n\t\tthis.emitter.emit('accountsChanged', this.accounts);\n\t}\n\n\tprotected async initialize(opts: EthereumProviderOptions) {\n\t\tthis.connection = opts.connection;\n\n\t\tif (!this.connection) {\n\t\t\tthrow new NotFoundMiraiConnectionError('No mirai connection found');\n\t\t}\n\n\t\tawait this.registerEventListener();\n\t}\n\n\tprivate async registerEventListener(): Promise<void> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst socket = await this.connection.ws.establish(true);\n\n\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\tsocket.disconnect();\n\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t});\n\n\t\t\tsocket.on('connect', (args: any) => {\n\t\t\t\tresolve();\n\t\t\t});\n\n\t\t\tsocket.on(\n\t\t\t\tthis.connection.topicId,\n\t\t\t\t(\n\t\t\t\t\tpayload: IProviderEvents.BaseEventArgs<{\n\t\t\t\t\t\tevent: { name: string; data: any };\n\t\t\t\t\t\tchainId: string;\n\t\t\t\t\t}>,\n\t\t\t\t) => {\n\t\t\t\t\tconst { params } = payload;\n\n\t\t\t\t\tif (params && params !== undefined) {\n\t\t\t\t\t\tconst { event } = params;\n\t\t\t\t\t\tif (event.name === 'accountsChanged') {\n\t\t\t\t\t\t\tthis.accounts = this.parseAccounts(event.data);\n\t\t\t\t\t\t\tthis.emitter.emit('accountsChanged', this.accounts);\n\t\t\t\t\t\t} else if (event.name === 'chainChanged') {\n\t\t\t\t\t\t\tthis.setChainId(event.data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.emitter.emit(event.name as any, event.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tsocket.on('connect_error', () => {\n\t\t\t\treject(new Error('Connection error'));\n\t\t\t});\n\n\t\t\tsocket.connect();\n\t\t});\n\t}\n\n\tprotected reset() {\n\t\tthis.chainId = `0x${miraiTestnet.id.toString(16)}`;\n\t\tthis.accounts = [];\n\t}\n\n\tprotected persist() {}\n\n\tprotected parseAccounts(payload: string | string[]): string[] {\n\t\tif (typeof payload === 'string' || payload instanceof String) {\n\t\t\treturn [this.parseAccount(payload)];\n\t\t}\n\t\treturn payload.map((account: string) => this.parseAccount(account));\n\t}\n\n\tprotected parseAccount = (payload: any): string => {\n\t\treturn this.parseAccountId(payload).address;\n\t};\n}\n"],"mappings":";AAAA,SAASA,YAAY,QAAQ,QAAQ;AAWrC,SAASC,YAAY,QAAQ,wBAAwB;AACrD,SAASC,4BAA4B,QAAQ,6BAA6B;AAC1E,SAASC,UAAU,QAAQ,iCAAiC;AAyB5D,OAAO,SAASC,kBAAkBA,CAACC,MAAgB,EAAU;EAC5D,OAAOA,MAAM,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/B;AAEA,OAAO,SAASC,YAAYA,CAACC,OAAe,EAAU;EACrD,OAAOA,OAAO;AACf;;AAEA;;AAgCA,OAAO,MAAMC,aAAa,CAA8B;EAMvDC,WAAWA,CAAA,EAAG;IAAAC,eAAA,kBALG,IAAIX,YAAY,CAAC,CAAC;IAAAW,eAAA,mBACP,EAAE;IAAAA,eAAA;IAAAA,eAAA,uBAAAC,MAAA,CAERX,YAAY,CAACY,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC;IAAAH,eAAA,aAoEP,CAACI,KAAK,EAAEC,QAAQ,KAAK;MAC/D,IAAI,CAACC,OAAO,CAACC,EAAE,CAACH,KAAK,EAAEC,QAAQ,CAAC;MAChC,OAAO,IAAI;IACZ,CAAC;IAAAL,eAAA,eAE8C,CAACI,KAAK,EAAEC,QAAQ,KAAK;MACnE,IAAI,CAACC,OAAO,CAACE,IAAI,CAACJ,KAAK,EAAEC,QAAQ,CAAC;MAClC,OAAO,IAAI;IACZ,CAAC;IAAAL,eAAA,yBAEkE,CAACI,KAAK,EAAEC,QAAQ,KAAK;MACvF,IAAI,CAACC,OAAO,CAACG,cAAc,CAACL,KAAK,EAAEC,QAAQ,CAAC;MAC5C,OAAO,IAAI;IACZ,CAAC;IAAAL,eAAA,cAE4C,CAACI,KAAK,EAAEC,QAAQ,KAAK;MACjE,IAAI,CAACC,OAAO,CAACI,GAAG,CAACN,KAAK,EAAEC,QAAQ,CAAC;MACjC,OAAO,IAAI;IACZ,CAAC;IAAAL,eAAA,uBA2GyBW,OAAY,IAAa;MAClD,OAAO,IAAI,CAACC,cAAc,CAACD,OAAO,CAAC,CAACE,OAAO;IAC5C,CAAC;EA9LD,CAAC,CAFA;EACA;;EAGD,aAAaC,IAAIA,CAACC,IAA6B,EAA0B;IACxE,MAAMC,QAAQ,GAAG,IAAIlB,aAAa,CAAC,CAAC;IACpC,MAAMkB,QAAQ,CAACC,UAAU,CAACF,IAAI,CAAC;IAE/B,OAAOC,QAAQ;EAChB;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA,MAAaE,OAAOA,CAAcC,IAAiC,EAAc;IAChF,OAAO,MAAM3B,UAAU,CAAC4B,QAAQ,CAACC,WAAW,CAAC,IAAI,CAACC,UAAU,CAACC,SAAS,EAAE;MACvE1B,OAAO,KAAAI,MAAA,CAAK,IAAI,CAACqB,UAAU,CAACE,SAAS,OAAAvB,MAAA,CAAIwB,MAAM,CAACC,QAAQ,CAAC,IAAI,CAAC7B,OAAO,EAAE,EAAE,CAAC,CAAC,CAAE;MAC7EqB,OAAO,EAAEC;IACV,CAAC,CAAC;EACH;EAEA,MAAaQ,MAAMA,CAAA,EAA8B;IAChD,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACV,OAAO,CAAmB;MAAEW,MAAM,EAAE;IAAsB,CAAC,CAAC;IACxF,OAAOD,QAAQ;EAChB;EAEA,MAAaE,UAAUA,CAAA,EAA6B;IACnD,MAAMC,KAAK,GAAG,MAAM,IAAI,CAACb,OAAO,CAAC;MAAEW,MAAM,EAAE;IAAc,CAAC,CAAC;IAE3D,OAAOE,KAAK;EACb;EAEA,MAAaC,OAAOA,CAACjB,IAAiB,EAAiB;IACtD,IAAI,CAAC,IAAI,CAACO,UAAU,CAACW,WAAW,CAAC,CAAC,EAAE;MACnC,MAAM,IAAIC,KAAK,CAAC,+DAA+D,CAAC;IACjF;IAEA,IAAI,CAAC5B,OAAO,CAAC6B,IAAI,CAAC,SAAS,EAAE;MAAEtC,OAAO,EAAE,IAAI,CAACA;IAAQ,CAAC,CAAC;EACxD;EAsBA,IAAIuC,eAAeA,CAAA,EAAG;IACrB,OAAO,IAAI;EACZ;EAEUC,mBAAmBA,CAACxC,OAAe,EAAQ;IACpD,IAAI,CAACqB,OAAO,CAAC;MACZW,MAAM,EAAE,4BAA4B;MACpCS,MAAM,EAAE,CAAC;QAAEzC,OAAO,EAAEA,OAAO,CAACM,QAAQ,CAAC,EAAE;MAAE,CAAC;IAC3C,CAAC,CAAC;EACH;EAEUoC,YAAYA,CAAC1C,OAAe,EAAU;IAC/C,OAAO4B,MAAM,CAAC5B,OAAO,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;EACrC;EAEU6C,WAAWA,CAAC9C,MAAgB,EAAE;IACvC,IAAI,CAACY,OAAO,CAAC6B,IAAI,CAAC,cAAc,EAAE,IAAI,CAACtC,OAAO,CAAC;IAC/C,IAAI,CAAC4C,OAAO,CAAC,CAAC;EACf;EAEUC,UAAUA,CAACX,KAAa,EAAE;IACnC,IAAI,CAACM,mBAAmB,CAACN,KAAK,CAAC;EAChC;EAEUnB,cAAcA,CAAC+B,OAAe,EAAwC;IAC/E,MAAM,CAACnB,SAAS,EAAEoB,SAAS,EAAE/B,OAAO,CAAC,GAAG8B,OAAO,CAAChD,KAAK,CAAC,GAAG,CAAC;IAC1D,MAAME,OAAO,MAAAI,MAAA,CAAMuB,SAAS,OAAAvB,MAAA,CAAI2C,SAAS,CAAE;IAC3C,OAAO;MAAE/C,OAAO;MAAEgB;IAAQ,CAAC;EAC5B;EAEUgC,WAAWA,CAACjB,QAAkB,EAAE;IACzC,IAAI,CAACA,QAAQ,GAAGA,QAAQ,CAACkB,GAAG,CAAEC,CAAC,IAAK,IAAI,CAACnC,cAAc,CAACmC,CAAC,CAAC,CAAClC,OAAO,CAAC;IAEnE,IAAI,CAACP,OAAO,CAAC6B,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAACP,QAAQ,CAAC;EACpD;EAEA,MAAgBX,UAAUA,CAACF,IAA6B,EAAE;IACzD,IAAI,CAACO,UAAU,GAAGP,IAAI,CAACO,UAAU;IAEjC,IAAI,CAAC,IAAI,CAACA,UAAU,EAAE;MACrB,MAAM,IAAI/B,4BAA4B,CAAC,2BAA2B,CAAC;IACpE;IAEA,MAAM,IAAI,CAACyD,qBAAqB,CAAC,CAAC;EACnC;EAEA,MAAcA,qBAAqBA,CAAA,EAAkB;IACpD,OAAO,IAAIC,OAAO,CAAC,OAAOC,OAAO,EAAEC,MAAM,KAAK;MAC7C,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAC9B,UAAU,CAAC+B,EAAE,CAACC,SAAS,CAAC,IAAI,CAAC;MAEvDF,MAAM,CAAC7C,EAAE,CAAC,WAAW,EAAGY,IAAS,IAAK;QACrCiC,MAAM,CAACG,UAAU,CAAC,CAAC;QACnBJ,MAAM,CAAC,IAAIjB,KAAK,CAACsB,IAAI,CAACC,SAAS,CAACtC,IAAI,CAAC,CAAC,CAAC;MACxC,CAAC,CAAC;MAEFiC,MAAM,CAAC7C,EAAE,CAAC,SAAS,EAAGY,IAAS,IAAK;QACnC+B,OAAO,CAAC,CAAC;MACV,CAAC,CAAC;MAEFE,MAAM,CAAC7C,EAAE,CACR,IAAI,CAACe,UAAU,CAACoC,OAAO,EAEtB/C,OAGE,IACE;QACJ,MAAM;UAAE2B;QAAO,CAAC,GAAG3B,OAAO;QAE1B,IAAI2B,MAAM,IAAIA,MAAM,KAAKqB,SAAS,EAAE;UACnC,MAAM;YAAEvD;UAAM,CAAC,GAAGkC,MAAM;UACxB,IAAIlC,KAAK,CAACwD,IAAI,KAAK,iBAAiB,EAAE;YACrC,IAAI,CAAChC,QAAQ,GAAG,IAAI,CAACiC,aAAa,CAACzD,KAAK,CAAC0D,IAAI,CAAC;YAC9C,IAAI,CAACxD,OAAO,CAAC6B,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAACP,QAAQ,CAAC;UACpD,CAAC,MAAM,IAAIxB,KAAK,CAACwD,IAAI,KAAK,cAAc,EAAE;YACzC,IAAI,CAAClB,UAAU,CAACtC,KAAK,CAAC0D,IAAI,CAAC;UAC5B,CAAC,MAAM;YACN,IAAI,CAACxD,OAAO,CAAC6B,IAAI,CAAC/B,KAAK,CAACwD,IAAI,EAASxD,KAAK,CAAC0D,IAAI,CAAC;UACjD;QACD;MACD,CACD,CAAC;MAEDV,MAAM,CAAC7C,EAAE,CAAC,eAAe,EAAE,MAAM;QAChC4C,MAAM,CAAC,IAAIjB,KAAK,CAAC,kBAAkB,CAAC,CAAC;MACtC,CAAC,CAAC;MAEFkB,MAAM,CAACpB,OAAO,CAAC,CAAC;IACjB,CAAC,CAAC;EACH;EAEU+B,KAAKA,CAAA,EAAG;IACjB,IAAI,CAAClE,OAAO,QAAAI,MAAA,CAAQX,YAAY,CAACY,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC,CAAE;IAClD,IAAI,CAACyB,QAAQ,GAAG,EAAE;EACnB;EAEUa,OAAOA,CAAA,EAAG,CAAC;EAEXoB,aAAaA,CAAClD,OAA0B,EAAY;IAC7D,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,YAAYqD,MAAM,EAAE;MAC7D,OAAO,CAAC,IAAI,CAACC,YAAY,CAACtD,OAAO,CAAC,CAAC;IACpC;IACA,OAAOA,OAAO,CAACmC,GAAG,CAAEH,OAAe,IAAK,IAAI,CAACsB,YAAY,CAACtB,OAAO,CAAC,CAAC;EACpE;AAKD"},"metadata":{},"sourceType":"module","externalDependencies":[]}