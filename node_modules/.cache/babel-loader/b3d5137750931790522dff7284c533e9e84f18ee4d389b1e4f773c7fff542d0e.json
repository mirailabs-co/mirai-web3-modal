{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { EventEmitter } from 'events';\nimport { SignerWebSocketService } from '../transports/websocket/ws-signer';\nexport function getRpcUrl(chainId, rpc) {\n  let rpcUrl;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n  }\n  return rpcUrl;\n}\nexport function getEthereumChainId(chains) {\n  return Number(chains[0].split(':')[1]);\n}\nexport function toHexChainId(chainId) {\n  return \"0x\".concat(chainId.toString(16));\n}\n\n// helper type to force setting at least one value in an array\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\n\nexport class MiraiProvider {\n  constructor() {\n    _defineProperty(this, \"emitter\", new EventEmitter());\n    _defineProperty(this, \"accounts\", []);\n    _defineProperty(this, \"_signer\", void 0);\n    _defineProperty(this, \"chainId\", 1);\n    _defineProperty(this, \"rpc\", void 0);\n    _defineProperty(this, \"on\", (event, listener) => {\n      this.emitter.on(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"once\", (event, listener) => {\n      this.emitter.once(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"removeListener\", (event, listener) => {\n      this.emitter.removeListener(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"off\", (event, listener) => {\n      this.emitter.off(event, listener);\n      return this;\n    });\n    _defineProperty(this, \"parseAccount\", payload => {\n      console.log('payload', payload);\n      return this.parseAccountId(payload).address;\n    });\n    // assigned during initialize\n    this._signer = new SignerWebSocketService();\n    this.rpc = {};\n  }\n  static async init(opts) {\n    const provider = new MiraiProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n  async request(args) {\n    return new Promise(async (resolve, reject) => {\n      const socket = await this._signer.establish(true);\n      socket.internal().once(args.method, message => {\n        console.log(':message', message);\n      });\n      socket.on('exception', args => {\n        socket.disconnect();\n        reject(new Error(JSON.stringify(args)));\n      });\n      socket.on('connect', () => {\n        console.log('emitted', args);\n        socket.getSocket().emit(args.method, args.params, data => {\n          console.log('data receive method', data);\n          if (data.code) {\n            reject(new Error(data.message));\n          }\n          resolve(data);\n        });\n      });\n      socket.on('connect_error', () => {\n        reject(new Error('Connection error'));\n      });\n      socket.connect();\n    });\n  }\n  async enable() {\n    const accounts = await this.request({\n      method: 'eth_requestAccounts'\n    });\n    return accounts;\n  }\n  async getChainId() {\n    const chain = await this.request({\n      method: 'eth_chainId'\n    });\n    console.log('chain', chain);\n    return chain;\n  }\n  async connect(opts) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const socket = await this._signer.establish(true);\n        socket.on('exception', args => {\n          socket.disconnect();\n          console.log('disconnect');\n          reject(new Error(JSON.stringify(args)));\n        });\n        socket.on('connect', e => {\n          console.log('connected');\n        });\n        socket.on('connect_error', () => {\n          reject(new Error('Connection error'));\n        });\n        socket.on('session', resp => {\n          try {\n            if (resp.code === 0) {\n              throw new Error(JSON.stringify(resp.data));\n            }\n            const {\n              namespaces\n            } = resp.data;\n\n            // if(namespaces['eip155']){\n\n            // }\n\n            // this.setAccounts(namespaces['eip155']['accounts']);\n            resolve(resp.data);\n          } catch (e) {\n            reject(e);\n          }\n        });\n        socket.on('chainChanged', resp => {\n          console.log('chains', resp);\n          if (resp.code === 0) {\n            throw new Error(JSON.stringify(resp.data));\n          }\n          const chainId = resp.data;\n          this.setChainId(chainId);\n        });\n        socket.on('accountsChanged', resp => {\n          if (resp.code === 0) {\n            throw new Error(JSON.stringify(resp.data));\n          }\n          const accounts = resp.data;\n          this.setAccounts(this.parseAccounts(accounts));\n        });\n        socket.connect();\n        this.setChainIds(this.rpc.chains);\n        this.emitter.emit('connect', {\n          chainId: toHexChainId(this.chainId)\n        });\n      } catch (error) {\n        console.error(error);\n        throw error;\n      } finally {}\n    });\n  }\n  async disconnect() {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const socket = await this._signer.establish(true);\n        socket.on('exception', args => {\n          socket.disconnect();\n          console.log('disconnect');\n          reject(new Error(JSON.stringify(args)));\n        });\n        console.time('WS get-pail');\n        socket.on('connect', () => {\n          console.log('connected');\n        });\n        socket.on('connect_error', () => {\n          reject(new Error('Connection error'));\n        });\n        socket.disconnect();\n        this.emitter.emit('disconnect', {});\n      } catch (error) {\n        console.error(error);\n        throw error;\n      } finally {\n        this.reset();\n      }\n    });\n  }\n  get isWalletConnect() {\n    return true;\n  }\n  switchEthereumChain(chainId) {\n    this.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{\n        chainId: chainId.toString(16)\n      }]\n    });\n  }\n  parseChainId(chainId) {\n    return Number(chainId.split(':')[1]);\n  }\n  setChainIds(chains) {\n    this.emitter.emit('chainChanged', toHexChainId(this.chainId));\n    this.persist();\n  }\n  setChainId(chain) {\n    this.switchEthereumChain(chain);\n  }\n  parseAccountId(account) {\n    const [namespace, reference, address] = account.split(':');\n    const chainId = \"\".concat(namespace, \":\").concat(reference);\n    return {\n      chainId,\n      address\n    };\n  }\n  setAccounts(accounts) {\n    this.accounts = accounts.map(x => this.parseAccountId(x).address);\n    this.emitter.emit('accountsChanged', this.accounts);\n  }\n  buildRpcMap(chains, projectId) {\n    const map = {};\n    chains.forEach(chain => {\n      map[chain] = this.getRpcUrl(chain, projectId);\n    });\n    return map;\n  }\n  async initialize(opts) {\n    // this.chainId = this.rpc.chains.length\n    //     ? getEthereumChainId(this.rpc.chains)\n    //     : getEthereumChainId(this.rpc.optionalChains);\n    // await this.registerEventListeners();\n    // await this.loadPersistedSession();\n  }\n  getRpcUrl(chainId, projectId) {\n    var _this$rpc$rpcMap;\n    return (_this$rpc$rpcMap = this.rpc.rpcMap) === null || _this$rpc$rpcMap === void 0 ? void 0 : _this$rpc$rpcMap[chainId];\n  }\n  reset() {\n    this.chainId = 1;\n    this.accounts = [];\n  }\n  persist() {}\n  parseAccounts(payload) {\n    if (typeof payload === 'string' || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map(account => this.parseAccount(account));\n  }\n}","map":{"version":3,"names":["EventEmitter","SignerWebSocketService","getRpcUrl","chainId","rpc","rpcUrl","rpcMap","getEthereumChainId","chains","Number","split","toHexChainId","concat","toString","MiraiProvider","constructor","_defineProperty","event","listener","emitter","on","once","removeListener","off","payload","console","log","parseAccountId","address","_signer","init","opts","provider","initialize","request","args","Promise","resolve","reject","socket","establish","internal","method","message","disconnect","Error","JSON","stringify","getSocket","emit","params","data","code","connect","enable","accounts","getChainId","chain","e","resp","namespaces","setChainId","setAccounts","parseAccounts","setChainIds","error","time","reset","isWalletConnect","switchEthereumChain","parseChainId","persist","account","namespace","reference","map","x","buildRpcMap","projectId","forEach","_this$rpc$rpcMap","String","parseAccount"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/providers/mirai-provider.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport {\n\tIEthereumProvider as IProvider,\n\tIEthereumProviderEvents,\n\tProviderAccounts,\n\tRequestArguments,\n\tProviderChainId,\n} from './types';\nimport { SignerWebSocketService } from '../transports/websocket/ws-signer';\n\nexport type RpcMethod =\n\t| 'personal_sign'\n\t| 'eth_sendTransaction'\n\t| 'eth_accounts'\n\t| 'eth_requestAccounts'\n\t| 'eth_call'\n\t| 'eth_getBalance'\n\t| 'eth_sendRawTransaction'\n\t| 'eth_sign'\n\t| 'eth_signTransaction'\n\t| 'eth_signTypedData'\n\t| 'eth_signTypedData_v3'\n\t| 'eth_signTypedData_v4'\n\t| 'wallet_switchEthereumChain'\n\t| 'wallet_addEthereumChain'\n\t| 'wallet_getPermissions'\n\t| 'wallet_requestPermissions'\n\t| 'wallet_registerOnboarding'\n\t| 'wallet_watchAsset'\n\t| 'wallet_scanQRCode';\n\nexport type RpcEvent = 'accountsChanged' | 'chainChanged' | 'message' | 'disconnect' | 'connect';\n\nexport interface EthereumRpcMap {\n\t[chainId: string]: string;\n}\n\nexport interface SessionEvent {\n\tevent: { name: string; data: any };\n\tchainId: string;\n}\n\nexport interface EthereumRpcConfig {\n\tchains: string[];\n\toptionalChains: string[];\n\tmethods: string[];\n\toptionalMethods?: string[];\n\t/**\n\t * @description Events that the wallet MUST support or the connection will be rejected\n\t */\n\tevents: string[];\n\toptionalEvents?: string[];\n\trpcMap: EthereumRpcMap;\n}\n\nexport interface ConnectOps {\n\tchains?: number[];\n\toptionalChains?: number[];\n\trpcMap?: EthereumRpcMap;\n\tpairingTopic?: string;\n\tchainId: number;\n}\n\nexport interface IEthereumProvider extends IProvider {\n\tconnect(opts?: ConnectOps | undefined): Promise<WalletConnectSession>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n\tlet rpcUrl: string | undefined;\n\tif (rpc.rpcMap) {\n\t\trpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n\t}\n\treturn rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n\treturn Number(chains[0].split(':')[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n\treturn `0x${chainId.toString(16)}`;\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n\t0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n\t| {\n\t\t\tchains: ArrayOneOrMore<number>;\n\t\t\toptionalChains?: number[];\n\t  }\n\t| {\n\t\t\tchains?: number[];\n\t\t\toptionalChains: ArrayOneOrMore<number>;\n\t  };\n\nexport type EthereumProviderOptions = {\n\tmethods?: string[];\n\t/**\n\t * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n\t */\n\toptionalMethods?: string[];\n\tevents?: string[];\n\toptionalEvents?: string[];\n\trpcMap?: EthereumRpcMap;\n} & ChainsProps;\n\nexport type WalletConnectSession = {\n\ttopic: string;\n\texpiry: number;\n\tacknowledged: boolean;\n\tpairingTopic: string;\n\tcontroller: string;\n\tpeer: {\n\t\tpublicKey: string;\n\t\tmetadata: {\n\t\t\tname: string;\n\t\t\tdescription: string;\n\t\t\turl: string;\n\t\t\ticons: [];\n\t\t};\n\t};\n\tnamespaces?: {\n\t\taccounts: string[];\n\t\tevents: string[];\n\t};\n};\n\nexport class MiraiProvider implements IEthereumProvider {\n\tpublic emitter = new EventEmitter();\n\tpublic accounts: string[] = [];\n\tprivate _signer: InstanceType<typeof SignerWebSocketService>;\n\tpublic chainId = 1;\n\n\tprotected rpc: EthereumRpcConfig;\n\n\tconstructor() {\n\t\t// assigned during initialize\n\t\tthis._signer = new SignerWebSocketService();\n\t\tthis.rpc = {} as EthereumRpcConfig;\n\t}\n\n\tstatic async init(opts: EthereumProviderOptions): Promise<MiraiProvider> {\n\t\tconst provider = new MiraiProvider();\n\t\tawait provider.initialize(opts);\n\n\t\treturn provider;\n\t}\n\n\tpublic async request<T = unknown>(args: RequestArguments): Promise<T> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst socket = await this._signer.establish(true);\n\n\t\t\tsocket.internal().once(args.method, (message: string) => {\n\t\t\t\tconsole.log(':message', message);\n\t\t\t});\n\n\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\tsocket.disconnect();\n\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t});\n\n\t\t\tsocket.on('connect', () => {\n\t\t\t\tconsole.log('emitted', args);\n\t\t\t\tsocket.getSocket().emit(args.method, args.params, (data: T & { code: number; message: string }) => {\n\t\t\t\t\tconsole.log('data receive method', data);\n\n\t\t\t\t\tif (data.code) {\n\t\t\t\t\t\treject(new Error(data.message));\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tsocket.on('connect_error', () => {\n\t\t\t\treject(new Error('Connection error'));\n\t\t\t});\n\n\t\t\tsocket.connect();\n\t\t});\n\t}\n\n\tpublic async enable(): Promise<ProviderAccounts> {\n\t\tconst accounts = await this.request({ method: 'eth_requestAccounts' });\n\t\treturn accounts as ProviderAccounts;\n\t}\n\n\tpublic async getChainId(): Promise<ProviderChainId> {\n\t\tconst chain = await this.request({ method: 'eth_chainId' });\n\n\t\tconsole.log('chain', chain);\n\t\treturn chain as ProviderChainId;\n\t}\n\n\tpublic async connect(opts?: ConnectOps): Promise<WalletConnectSession> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst socket = await this._signer.establish(true);\n\n\t\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\t\tsocket.disconnect();\n\t\t\t\t\tconsole.log('disconnect');\n\n\t\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t\t});\n\n\t\t\t\tsocket.on('connect', (e: any) => {\n\t\t\t\t\tconsole.log('connected');\n\t\t\t\t});\n\n\t\t\t\tsocket.on('connect_error', () => {\n\t\t\t\t\treject(new Error('Connection error'));\n\t\t\t\t});\n\n\t\t\t\tsocket.on('session', (resp: any) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (resp.code === 0) {\n\t\t\t\t\t\t\tthrow new Error(JSON.stringify(resp.data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst { namespaces } = resp.data as WalletConnectSession;\n\n\t\t\t\t\t\t// if(namespaces['eip155']){\n\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t// this.setAccounts(namespaces['eip155']['accounts']);\n\t\t\t\t\t\tresolve(resp.data);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tsocket.on('chainChanged', (resp: any) => {\n\t\t\t\t\tconsole.log('chains', resp);\n\t\t\t\t\tif (resp.code === 0) {\n\t\t\t\t\t\tthrow new Error(JSON.stringify(resp.data));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst chainId = resp.data as number;\n\n\t\t\t\t\tthis.setChainId(chainId);\n\t\t\t\t});\n\n\t\t\t\tsocket.on('accountsChanged', (resp: any) => {\n\t\t\t\t\tif (resp.code === 0) {\n\t\t\t\t\t\tthrow new Error(JSON.stringify(resp.data));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst accounts = resp.data as string[];\n\n\t\t\t\t\tthis.setAccounts(this.parseAccounts(accounts));\n\t\t\t\t});\n\n\t\t\t\tsocket.connect();\n\t\t\t\tthis.setChainIds(this.rpc.chains);\n\t\t\t\tthis.emitter.emit('connect', { chainId: toHexChainId(this.chainId) });\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async disconnect(): Promise<void> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst socket = await this._signer.establish(true);\n\n\t\t\t\tsocket.on('exception', (args: any) => {\n\t\t\t\t\tsocket.disconnect();\n\t\t\t\t\tconsole.log('disconnect');\n\n\t\t\t\t\treject(new Error(JSON.stringify(args)));\n\t\t\t\t});\n\n\t\t\t\tconsole.time('WS get-pail');\n\t\t\t\tsocket.on('connect', () => {\n\t\t\t\t\tconsole.log('connected');\n\t\t\t\t});\n\n\t\t\t\tsocket.on('connect_error', () => {\n\t\t\t\t\treject(new Error('Connection error'));\n\t\t\t\t});\n\n\t\t\t\tsocket.disconnect();\n\t\t\t\tthis.emitter.emit('disconnect', {});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic on: IEthereumProviderEvents['on'] = (event, listener) => {\n\t\tthis.emitter.on(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic once: IEthereumProviderEvents['once'] = (event, listener) => {\n\t\tthis.emitter.once(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic removeListener: IEthereumProviderEvents['removeListener'] = (event, listener) => {\n\t\tthis.emitter.removeListener(event, listener);\n\t\treturn this;\n\t};\n\n\tpublic off: IEthereumProviderEvents['off'] = (event, listener) => {\n\t\tthis.emitter.off(event, listener);\n\t\treturn this;\n\t};\n\n\tget isWalletConnect() {\n\t\treturn true;\n\t}\n\n\tprotected switchEthereumChain(chainId: number): void {\n\t\tthis.request({\n\t\t\tmethod: 'wallet_switchEthereumChain',\n\t\t\tparams: [{ chainId: chainId.toString(16) }],\n\t\t});\n\t}\n\n\tprotected parseChainId(chainId: string): number {\n\t\treturn Number(chainId.split(':')[1]);\n\t}\n\n\tprotected setChainIds(chains: string[]) {\n\t\tthis.emitter.emit('chainChanged', toHexChainId(this.chainId));\n\t\tthis.persist();\n\t}\n\n\tprotected setChainId(chain: number) {\n\t\tthis.switchEthereumChain(chain);\n\t}\n\n\tprotected parseAccountId(account: string): { chainId: string; address: string } {\n\t\tconst [namespace, reference, address] = account.split(':');\n\t\tconst chainId = `${namespace}:${reference}`;\n\t\treturn { chainId, address };\n\t}\n\n\tprotected setAccounts(accounts: string[]) {\n\t\tthis.accounts = accounts.map((x) => this.parseAccountId(x).address);\n\t\tthis.emitter.emit('accountsChanged', this.accounts);\n\t}\n\n\tprotected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n\t\tconst map: EthereumRpcMap = {};\n\t\tchains.forEach((chain) => {\n\t\t\tmap[chain] = this.getRpcUrl(chain, projectId);\n\t\t});\n\t\treturn map;\n\t}\n\n\tprotected async initialize(opts: EthereumProviderOptions) {\n\t\t// this.chainId = this.rpc.chains.length\n\t\t//     ? getEthereumChainId(this.rpc.chains)\n\t\t//     : getEthereumChainId(this.rpc.optionalChains);\n\t\t// await this.registerEventListeners();\n\t\t// await this.loadPersistedSession();\n\t}\n\n\tprotected getRpcUrl(chainId: number, projectId?: string): string {\n\t\treturn this.rpc.rpcMap?.[chainId];\n\t}\n\n\tprotected reset() {\n\t\tthis.chainId = 1;\n\t\tthis.accounts = [];\n\t}\n\n\tprotected persist() {}\n\n\tprotected parseAccounts(payload: string | string[]): string[] {\n\t\tif (typeof payload === 'string' || payload instanceof String) {\n\t\t\treturn [this.parseAccount(payload)];\n\t\t}\n\t\treturn payload.map((account: string) => this.parseAccount(account));\n\t}\n\n\tprotected parseAccount = (payload: any): string => {\n\t\tconsole.log('payload', payload);\n\t\treturn this.parseAccountId(payload).address;\n\t};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}