{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { Connector } from '../connectors/connector';\nimport { MiraiProvider } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { createWalletClient } from '../clients/wallet-client';\nimport { MiraiConnection } from '../connection/mirai-connection';\nimport { miraiTestnet } from '../../constants/chains';\nexport class MiraiConnector extends Connector {\n  constructor(config) {\n    super(_objectSpread(_objectSpread({}, config), {}, {\n      options: _objectSpread({}, config.options)\n    }));\n    _defineProperty(this, \"id\", 'miraijsConnect');\n    _defineProperty(this, \"name\", 'miraijsConnect');\n    _defineProperty(this, \"ready\", true);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"auth\", void 0);\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: ethers.getAddress(accounts[0])\n      });\n    });\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    _defineProperty(this, \"onDisconnect\", () => {\n      this.emit('disconnect');\n    });\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit('message', {\n        type: 'display_uri',\n        data: uri\n      });\n    });\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit('connect', {});\n    });\n    this.auth = config.auth;\n    this.createProvider();\n  }\n  async connect() {\n    let {\n      chainId,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      chainId: miraiTestnet.id\n    };\n    try {\n      const provider = await this.getProvider();\n      this.setupListeners();\n      this.emit('message', {\n        type: 'connecting. scan qrcode ...'\n      });\n      await provider.connect({\n        pairingTopic,\n        chains: [chainId],\n        chainId\n      });\n      this.emit('message', {\n        type: 'connected'\n      });\n\n      // If session exists and chains are authorized, enable provider for required chain\n      const accounts = await provider.enable();\n\n      // await this.switchChain(chainId);\n\n      console.log('accounts', accounts);\n      let account;\n      if (accounts && accounts.length > 0) {\n        account = ethers.getAddress(accounts[0]);\n      }\n      const chain = await provider.getChainId();\n      const id = Number(parseInt(chain, 16));\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        }\n      };\n    } catch (error) {\n      // if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n      //     throw new UserRejectedRequestError(error as Error);\n      // }\n      throw error;\n    }\n  }\n  async getWalletClient() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    // const chain = this.chains.find((x) => x.id === chainId);\n    if (!provider) throw new Error('provider is required.');\n    return createWalletClient({\n      account,\n      chainId,\n      provider\n    });\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    try {\n      await provider.disconnect();\n    } catch (error) {\n      if (!/No matching key/i.test(error.message)) throw error;\n    } finally {\n      this.removeAllListeners();\n    }\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    console.log('getAccount', accounts);\n    return ethers.getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId,\n      getChainId,\n      request\n    } = await this.getProvider();\n    if (!chainId) {\n      const chain = await getChainId();\n      console.log('chain', chain);\n      return Number(chain.split(':')[1]);\n    }\n    return chainId;\n  }\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.provider) await this.createProvider();\n    if (chainId) await this.switchChain(chainId || this.chains[0].id);\n    return this.provider;\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n      // If an account does not exist on the session, then the connector is unauthorized.\n      if (!account) return false;\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain => chain.id === chainId);\n    // if (!chain) throw new Error('chain not found on connector.');\n    // if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n    try {\n      const provider = await this.getProvider();\n      const chain = await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: \"\".concat(ethers.toBeHex(chainId))\n        }]\n      });\n\n      // console.log('chains', chains);\n\n      return chainId;\n    } catch (error) {\n      console.log('error', error);\n      // const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n      // if (/user rejected request/i.test(message)) {\n      //     throw new UserRejectedRequestError(error as Error);\n      // }\n      // throw new SwitchChainError(error as Error);\n    }\n  }\n\n  async createProvider() {\n    return this.initProvider();\n  }\n  async initProvider() {\n    if (!this.auth || this.auth === undefined) {\n      throw new Error('Authentication not found');\n    }\n    const connection = await MiraiConnection.init({\n      auth: this.auth\n    });\n    if (!connection) {\n      throw new Error('Connection request reset. Please try again.');\n    }\n    if (!connection.isConnected()) {\n      throw new Error('Connection is not connnected. Please try again.');\n    }\n    this.provider = await MiraiProvider.init({\n      connection\n    });\n  }\n  setupListeners() {\n    if (!this.provider) return;\n    this.removeListeners();\n    this.provider.on('accountsChanged', this.onAccountsChanged);\n    this.provider.on('chainChanged', this.onChainChanged);\n    this.provider.on('disconnect', this.onDisconnect);\n    this.provider.on('connect', this.onConnect);\n  }\n  removeListeners() {\n    if (!this.provider) return;\n    this.provider.removeListener('accountsChanged', this.onAccountsChanged);\n    this.provider.removeListener('chainChanged', this.onChainChanged);\n    this.provider.removeListener('disconnect', this.onDisconnect);\n    this.provider.removeListener('connect', this.onConnect);\n  }\n}\n\n// export default MiraiConnector;","map":{"version":3,"names":["Connector","MiraiProvider","ethers","createWalletClient","MiraiConnection","miraiTestnet","MiraiConnector","constructor","config","_objectSpread","options","_defineProperty","accounts","length","emit","account","getAddress","chainId","id","Number","unsupported","isChainUnsupported","chain","uri","type","data","auth","createProvider","connect","pairingTopic","arguments","undefined","provider","getProvider","setupListeners","chains","enable","console","log","getChainId","parseInt","error","getWalletClient","Promise","all","getAccount","Error","disconnect","test","message","removeAllListeners","request","split","switchChain","isAuthorized","find","method","params","concat","toBeHex","initProvider","connection","init","isConnected","removeListeners","on","onAccountsChanged","onChainChanged","onDisconnect","onConnect","removeListener"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/mirai-connector.ts"],"sourcesContent":["import { Connector } from '../connectors/connector';\nimport { MiraiProvider, ConnectOps } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { IWalletClient, createWalletClient } from '../clients/wallet-client';\nimport { auth } from '../../constants';\nimport { MiraiConnection } from '../connection/mirai-connection';\nimport { miraiTestnet } from '../../constants/chains';\n\nexport class MiraiConnector extends Connector<MiraiProvider, any> {\n\treadonly id = 'miraijsConnect';\n\treadonly name = 'miraijsConnect';\n\treadonly ready = true;\n\n\tprovider?: MiraiProvider;\n\tauth?: auth.TMiraiToken;\n\n\tconstructor(config: { options: any; auth?: auth.TMiraiToken }) {\n\t\tsuper({\n\t\t\t...config,\n\t\t\toptions: { ...config.options },\n\t\t});\n\t\tthis.auth = config.auth;\n\t\tthis.createProvider();\n\t}\n\n\tasync connect({ chainId, pairingTopic }: ConnectOps = { chainId: miraiTestnet.id }) {\n\t\ttry {\n\t\t\tconst provider = await this.getProvider();\n\t\t\tthis.setupListeners();\n\n\t\t\tthis.emit('message', { type: 'connecting. scan qrcode ...' });\n\n\t\t\tawait provider.connect({\n\t\t\t\tpairingTopic,\n\t\t\t\tchains: [chainId],\n\t\t\t\tchainId,\n\t\t\t});\n\n\t\t\tthis.emit('message', { type: 'connected' });\n\n\t\t\t// If session exists and chains are authorized, enable provider for required chain\n\t\t\tconst accounts = await provider.enable();\n\n\t\t\t// await this.switchChain(chainId);\n\n\t\t\tconsole.log('accounts', accounts);\n\t\t\tlet account: string;\n\t\t\tif (accounts && accounts.length > 0) {\n\t\t\t\taccount = ethers.getAddress(accounts[0]);\n\t\t\t}\n\n\t\t\tconst chain = await provider.getChainId();\n\t\t\tconst id = Number(parseInt(chain, 16));\n\n\t\t\tconst unsupported = this.isChainUnsupported(id);\n\n\t\t\treturn {\n\t\t\t\taccount,\n\t\t\t\tchain: { id, unsupported },\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getWalletClient({ chainId }: { chainId?: number } = {}): Promise<IWalletClient> {\n\t\tconst [provider, account] = await Promise.all([this.getProvider({ chainId }), this.getAccount()]);\n\t\t// const chain = this.chains.find((x) => x.id === chainId);\n\t\tif (!provider) throw new Error('provider is required.');\n\t\treturn createWalletClient({\n\t\t\taccount,\n\t\t\tchainId,\n\t\t\tprovider,\n\t\t});\n\t}\n\n\tasync disconnect() {\n\t\tconst provider = await this.getProvider();\n\t\ttry {\n\t\t\tawait provider.disconnect();\n\t\t} catch (error) {\n\t\t\tif (!/No matching key/i.test((error as Error).message)) throw error;\n\t\t} finally {\n\t\t\tthis.removeAllListeners();\n\t\t}\n\t}\n\n\tasync getAccount(): Promise<string> {\n\t\tconst { accounts } = await this.getProvider();\n\n\t\tconsole.log('getAccount', accounts);\n\t\treturn ethers.getAddress(accounts[0]!);\n\t}\n\n\tasync getChainId() {\n\t\tconst { chainId, getChainId, request } = await this.getProvider();\n\t\tif (!chainId) {\n\t\t\tconst chain = await getChainId();\n\t\t\tconsole.log('chain', chain);\n\t\t\treturn Number(chain.split(':')[1]);\n\t\t}\n\t\treturn chainId;\n\t}\n\n\tasync getProvider({ chainId }: { chainId?: number } = {}) {\n\t\tif (!this.provider) await this.createProvider();\n\t\tif (chainId) await this.switchChain(chainId || this.chains[0].id);\n\t\treturn this.provider;\n\t}\n\n\tasync isAuthorized() {\n\t\ttry {\n\t\t\tconst [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n\t\t\t// If an account does not exist on the session, then the connector is unauthorized.\n\t\t\tif (!account) return false;\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync switchChain(chainId: number) {\n\t\tconst chain = this.chains.find((chain) => chain.id === chainId);\n\t\t// if (!chain) throw new Error('chain not found on connector.');\n\t\t// if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n\t\ttry {\n\t\t\tconst provider = await this.getProvider();\n\n\t\t\tconst chain = await provider.request({\n\t\t\t\tmethod: 'wallet_switchEthereumChain',\n\t\t\t\tparams: [{ chainId: `${ethers.toBeHex(chainId)}` }],\n\t\t\t});\n\n\t\t\t// console.log('chains', chains);\n\n\t\t\treturn chainId;\n\t\t} catch (error) {\n\t\t\tconsole.log('error', error);\n\t\t\t// const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n\t\t\t// if (/user rejected request/i.test(message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\t// throw new SwitchChainError(error as Error);\n\t\t}\n\t}\n\n\tasync createProvider() {\n\t\treturn this.initProvider();\n\t}\n\n\tasync initProvider() {\n\t\tif (!this.auth || this.auth === undefined) {\n\t\t\tthrow new Error('Authentication not found');\n\t\t}\n\n\t\tconst connection = await MiraiConnection.init({\n\t\t\tauth: this.auth,\n\t\t});\n\n\t\tif (!connection) {\n\t\t\tthrow new Error('Connection request reset. Please try again.');\n\t\t}\n\n\t\tif (!connection.isConnected()) {\n\t\t\tthrow new Error('Connection is not connnected. Please try again.');\n\t\t}\n\n\t\tthis.provider = await MiraiProvider.init({\n\t\t\tconnection,\n\t\t});\n\t}\n\n\tsetupListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.removeListeners();\n\t\tthis.provider.on('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.on('chainChanged', this.onChainChanged);\n\t\tthis.provider.on('disconnect', this.onDisconnect);\n\t\tthis.provider.on('connect', this.onConnect);\n\t}\n\n\tremoveListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.provider.removeListener('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.removeListener('chainChanged', this.onChainChanged);\n\t\tthis.provider.removeListener('disconnect', this.onDisconnect);\n\t\tthis.provider.removeListener('connect', this.onConnect);\n\t}\n\n\tprotected onAccountsChanged = (accounts: string[]) => {\n\t\tif (accounts.length === 0) this.emit('disconnect');\n\t\telse this.emit('change', { account: ethers.getAddress(accounts[0]!) });\n\t};\n\n\tprotected onChainChanged = (chainId: number | string) => {\n\t\tconst id = Number(chainId);\n\t\tconst unsupported = this.isChainUnsupported(id);\n\t\tthis.emit('change', { chain: { id, unsupported } });\n\t};\n\n\tprotected onDisconnect = () => {\n\t\tthis.emit('disconnect');\n\t};\n\n\tprotected onDisplayUri = (uri: string) => {\n\t\tthis.emit('message', { type: 'display_uri', data: uri });\n\t};\n\n\tprotected onConnect = () => {\n\t\tthis.emit('connect', {});\n\t};\n}\n\n// export default MiraiConnector;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}