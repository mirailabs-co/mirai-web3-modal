{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { Connector } from '../connectors/connector';\nimport { MiraiProvider } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { createWalletClient } from '../clients/wallet-client';\nimport { MiraiConnection } from '../connection/mirai-connection';\nconst ETH_CHAIN_ID = 1;\nexport class MiraiConnector extends Connector {\n  constructor(config) {\n    super(_objectSpread(_objectSpread({}, config), {}, {\n      options: _objectSpread({\n        isNewChainsStale: true\n      }, config.options)\n    }));\n    _defineProperty(this, \"id\", 'miraijsConnect');\n    _defineProperty(this, \"name\", 'miraijsConnect');\n    _defineProperty(this, \"ready\", true);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: ethers.getAddress(accounts[0])\n      });\n    });\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    _defineProperty(this, \"onDisconnect\", () => {\n      this.emit('disconnect');\n    });\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit('message', {\n        type: 'display_uri',\n        data: uri\n      });\n    });\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit('connect', {});\n    });\n    this.init(config.auth);\n  }\n  async connect() {\n    let {\n      chainId,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      chainId: ETH_CHAIN_ID\n    };\n    try {\n      const provider = await this.getProvider();\n      this.setupListeners();\n      this.emit('message', {\n        type: 'connecting. scan qrcode ...'\n      });\n      await provider.connect({\n        pairingTopic,\n        chains: [chainId],\n        chainId\n      });\n      this.emit('message', {\n        type: 'connected'\n      });\n\n      // If session exists and chains are authorized, enable provider for required chain\n      const accounts = await provider.enable();\n\n      // await this.switchChain(chainId);\n\n      console.log('accounts', accounts);\n      const account = ethers.getAddress(accounts[0]);\n      const chain = await provider.getChainId();\n      const id = Number(parseInt(chain, 16));\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        }\n      };\n    } catch (error) {\n      // if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n      //     throw new UserRejectedRequestError(error as Error);\n      // }\n      throw error;\n    }\n  }\n  async getWalletClient() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    // const chain = this.chains.find((x) => x.id === chainId);\n    if (!provider) throw new Error('provider is required.');\n    return createWalletClient({\n      account,\n      chainId,\n      provider\n    });\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    try {\n      await provider.disconnect();\n    } catch (error) {\n      if (!/No matching key/i.test(error.message)) throw error;\n    } finally {\n      this.removeAllListeners();\n    }\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    console.log('getAccount', accounts);\n    return ethers.getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId,\n      getChainId,\n      request\n    } = await this.getProvider();\n    if (!chainId) {\n      const chain = await getChainId();\n      console.log('chain', chain);\n      return Number(chain.split(':')[1]);\n    }\n    return chainId;\n  }\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.provider) await this.init();\n    if (chainId) await this.switchChain(chainId || this.chains[0].id);\n    return this.provider;\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n      // If an account does not exist on the session, then the connector is unauthorized.\n      if (!account) return false;\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain => chain.id === chainId);\n    // if (!chain) throw new Error('chain not found on connector.');\n    // if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n    try {\n      // const provider = await this.getProvider();\n\n      // const chains = await provider.request({\n      //     method: 'wallet_switchEthereumChain',\n      //     params: [{ chainId: `${ethers.toBeHex(chainId)}` }],\n      // });\n\n      // console.log('chains', chains);\n\n      return chain;\n    } catch (error) {\n      console.log('error', error);\n      // const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n      // if (/user rejected request/i.test(message)) {\n      //     throw new UserRejectedRequestError(error as Error);\n      // }\n      // throw new SwitchChainError(error as Error);\n    }\n  }\n\n  async init(auth) {\n    if (!this.connection) {\n      this.connection = await MiraiConnection.init({\n        auth: _objectSpread({}, auth)\n      });\n      console.log('this.connection', this.connection);\n    }\n    return this.initProvider();\n  }\n  async initProvider() {\n    const [defaultChain, ...optionalChains] = this.chains.map(_ref => {\n      let {\n        id\n      } = _ref;\n      return id;\n    });\n    if (defaultChain) {\n      this.provider = await MiraiProvider.init({\n        chains: [defaultChain],\n        connection: {\n          authToken: this.connection.auth\n        }\n      });\n    }\n  }\n  setupListeners() {\n    if (!this.provider) return;\n    this.removeListeners();\n    this.provider.on('accountsChanged', this.onAccountsChanged);\n    this.provider.on('chainChanged', this.onChainChanged);\n    this.provider.on('disconnect', this.onDisconnect);\n    this.provider.on('connect', this.onConnect);\n  }\n  removeListeners() {\n    if (!this.provider) return;\n    this.provider.removeListener('accountsChanged', this.onAccountsChanged);\n    this.provider.removeListener('chainChanged', this.onChainChanged);\n    this.provider.removeListener('disconnect', this.onDisconnect);\n    this.provider.removeListener('connect', this.onConnect);\n  }\n}\n\n// export default MiraiConnector;","map":{"version":3,"names":["Connector","MiraiProvider","ethers","createWalletClient","MiraiConnection","ETH_CHAIN_ID","MiraiConnector","constructor","config","_objectSpread","options","isNewChainsStale","_defineProperty","accounts","length","emit","account","getAddress","chainId","id","Number","unsupported","isChainUnsupported","chain","uri","type","data","init","auth","connect","pairingTopic","arguments","undefined","provider","getProvider","setupListeners","chains","enable","console","log","getChainId","parseInt","error","getWalletClient","Promise","all","getAccount","Error","disconnect","test","message","removeAllListeners","request","split","switchChain","isAuthorized","find","connection","initProvider","defaultChain","optionalChains","map","_ref","authToken","removeListeners","on","onAccountsChanged","onChainChanged","onDisconnect","onConnect","removeListener"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/mirai-connector.ts"],"sourcesContent":["import { Connector } from '../connectors/connector';\nimport { MiraiProvider, ConnectOps } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { IWalletClient, createWalletClient } from '../clients/wallet-client';\nimport { Chain } from '../services/core/config';\nimport { MiraiConnection } from '../connection/mirai-connection';\n\nconst ETH_CHAIN_ID = 1;\n\nexport type MiraiAuthToken = {\n\taccess_token: string;\n\trefresh_token: string;\n};\n\nexport class MiraiConnector extends Connector<MiraiProvider, any> {\n\treadonly id = 'miraijsConnect';\n\treadonly name = 'miraijsConnect';\n\treadonly ready = true;\n\n\tprovider?: MiraiProvider;\n\tconnection?: MiraiConnection;\n\n\tconstructor(config: { chains?: Chain[]; options: any; auth?: MiraiAuthToken }) {\n\t\tsuper({\n\t\t\t...config,\n\t\t\toptions: { isNewChainsStale: true, ...config.options },\n\t\t});\n\t\tthis.init(config.auth);\n\t}\n\n\tasync connect({ chainId, pairingTopic }: ConnectOps = { chainId: ETH_CHAIN_ID }) {\n\t\ttry {\n\t\t\tconst provider = await this.getProvider();\n\t\t\tthis.setupListeners();\n\n\t\t\tthis.emit('message', { type: 'connecting. scan qrcode ...' });\n\n\t\t\tawait provider.connect({\n\t\t\t\tpairingTopic,\n\t\t\t\tchains: [chainId],\n\t\t\t\tchainId,\n\t\t\t});\n\n\t\t\tthis.emit('message', { type: 'connected' });\n\n\t\t\t// If session exists and chains are authorized, enable provider for required chain\n\t\t\tconst accounts = await provider.enable();\n\n\t\t\t// await this.switchChain(chainId);\n\n\t\t\tconsole.log('accounts', accounts);\n\n\t\t\tconst account = ethers.getAddress(accounts[0]);\n\t\t\tconst chain = await provider.getChainId();\n\t\t\tconst id = Number(parseInt(chain, 16));\n\n\t\t\tconst unsupported = this.isChainUnsupported(id);\n\n\t\t\treturn {\n\t\t\t\taccount,\n\t\t\t\tchain: { id, unsupported },\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getWalletClient({ chainId }: { chainId?: number } = {}): Promise<IWalletClient> {\n\t\tconst [provider, account] = await Promise.all([this.getProvider({ chainId }), this.getAccount()]);\n\t\t// const chain = this.chains.find((x) => x.id === chainId);\n\t\tif (!provider) throw new Error('provider is required.');\n\t\treturn createWalletClient({\n\t\t\taccount,\n\t\t\tchainId,\n\t\t\tprovider,\n\t\t});\n\t}\n\n\tasync disconnect() {\n\t\tconst provider = await this.getProvider();\n\t\ttry {\n\t\t\tawait provider.disconnect();\n\t\t} catch (error) {\n\t\t\tif (!/No matching key/i.test((error as Error).message)) throw error;\n\t\t} finally {\n\t\t\tthis.removeAllListeners();\n\t\t}\n\t}\n\n\tasync getAccount(): Promise<string> {\n\t\tconst { accounts } = await this.getProvider();\n\n\t\tconsole.log('getAccount', accounts);\n\t\treturn ethers.getAddress(accounts[0]!);\n\t}\n\n\tasync getChainId() {\n\t\tconst { chainId, getChainId, request } = await this.getProvider();\n\t\tif (!chainId) {\n\t\t\tconst chain = await getChainId();\n\t\t\tconsole.log('chain', chain);\n\t\t\treturn Number(chain.split(':')[1]);\n\t\t}\n\t\treturn chainId;\n\t}\n\n\tasync getProvider({ chainId }: { chainId?: number } = {}) {\n\t\tif (!this.provider) await this.init();\n\t\tif (chainId) await this.switchChain(chainId || this.chains[0].id);\n\t\treturn this.provider;\n\t}\n\n\tasync isAuthorized() {\n\t\ttry {\n\t\t\tconst [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n\t\t\t// If an account does not exist on the session, then the connector is unauthorized.\n\t\t\tif (!account) return false;\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync switchChain(chainId: number) {\n\t\tconst chain = this.chains.find((chain) => chain.id === chainId);\n\t\t// if (!chain) throw new Error('chain not found on connector.');\n\t\t// if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n\t\ttry {\n\t\t\t// const provider = await this.getProvider();\n\n\t\t\t// const chains = await provider.request({\n\t\t\t//     method: 'wallet_switchEthereumChain',\n\t\t\t//     params: [{ chainId: `${ethers.toBeHex(chainId)}` }],\n\t\t\t// });\n\n\t\t\t// console.log('chains', chains);\n\n\t\t\treturn chain;\n\t\t} catch (error) {\n\t\t\tconsole.log('error', error);\n\t\t\t// const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n\t\t\t// if (/user rejected request/i.test(message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\t// throw new SwitchChainError(error as Error);\n\t\t}\n\t}\n\n\tasync init(auth?: MiraiAuthToken) {\n\t\tif (!this.connection) {\n\t\t\tthis.connection = await MiraiConnection.init({\n\t\t\t\tauth: {\n\t\t\t\t\t...auth,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconsole.log('this.connection', this.connection);\n\t\t}\n\n\t\treturn this.initProvider();\n\t}\n\n\tasync initProvider() {\n\t\tconst [defaultChain, ...optionalChains] = this.chains.map(({ id }) => id);\n\t\tif (defaultChain) {\n\t\t\tthis.provider = await MiraiProvider.init({\n\t\t\t\tchains: [defaultChain],\n\t\t\t\tconnection: {\n\t\t\t\t\tauthToken: this.connection.auth,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tsetupListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.removeListeners();\n\t\tthis.provider.on('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.on('chainChanged', this.onChainChanged);\n\t\tthis.provider.on('disconnect', this.onDisconnect);\n\t\tthis.provider.on('connect', this.onConnect);\n\t}\n\n\tremoveListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.provider.removeListener('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.removeListener('chainChanged', this.onChainChanged);\n\t\tthis.provider.removeListener('disconnect', this.onDisconnect);\n\t\tthis.provider.removeListener('connect', this.onConnect);\n\t}\n\n\tprotected onAccountsChanged = (accounts: string[]) => {\n\t\tif (accounts.length === 0) this.emit('disconnect');\n\t\telse this.emit('change', { account: ethers.getAddress(accounts[0]!) });\n\t};\n\n\tprotected onChainChanged = (chainId: number | string) => {\n\t\tconst id = Number(chainId);\n\t\tconst unsupported = this.isChainUnsupported(id);\n\t\tthis.emit('change', { chain: { id, unsupported } });\n\t};\n\n\tprotected onDisconnect = () => {\n\t\tthis.emit('disconnect');\n\t};\n\n\tprotected onDisplayUri = (uri: string) => {\n\t\tthis.emit('message', { type: 'display_uri', data: uri });\n\t};\n\n\tprotected onConnect = () => {\n\t\tthis.emit('connect', {});\n\t};\n}\n\n// export default MiraiConnector;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}