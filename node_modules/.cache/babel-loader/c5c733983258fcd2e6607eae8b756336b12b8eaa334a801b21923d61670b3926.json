{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { Connector } from '../connectors/connector';\nimport { MiraiProvider } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { createWalletClient } from '../clients/wallet-client';\nimport { AuthToken } from '../../auth-client';\nconst ETH_CHAIN_ID = 1;\nconst getPeer = peer => {};\nexport class MiraiConnector extends Connector {\n  constructor(config) {\n    super(_objectSpread(_objectSpread({}, config), {}, {\n      options: _objectSpread({\n        isNewChainsStale: true\n      }, config.options)\n    }));\n    _defineProperty(this, \"id\", 'miraijsConnect');\n    _defineProperty(this, \"name\", 'miraijsConnect');\n    _defineProperty(this, \"ready\", true);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: ethers.getAddress(accounts[0])\n      });\n    });\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    _defineProperty(this, \"onDisconnect\", () => {\n      this.emit('disconnect');\n    });\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit('message', {\n        type: 'display_uri',\n        data: uri\n      });\n    });\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit('connect', {});\n    });\n    this.createProvider();\n  }\n  async connect() {\n    let {\n      chainId,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      chainId: ETH_CHAIN_ID\n    };\n    try {\n      const provider = await this.getProvider();\n      this.setupListeners();\n      this.emit('message', {\n        type: 'connecting. scan qrcode ...'\n      });\n      await provider.connect({\n        pairingTopic,\n        chains: [chainId],\n        chainId\n      });\n      this.emit('message', {\n        type: 'connected'\n      });\n\n      // If session exists and chains are authorized, enable provider for required chain\n      const accounts = await provider.enable();\n\n      // await this.switchChain(chainId);\n\n      console.log('accounts', accounts);\n      const account = ethers.getAddress(accounts[0]);\n      const chain = await provider.getChainId();\n      const id = Number(parseInt(chain, 16));\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        }\n      };\n    } catch (error) {\n      // if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n      //     throw new UserRejectedRequestError(error as Error);\n      // }\n      throw error;\n    }\n  }\n  async setWalletAuthentication(auth) {\n    await AuthToken.save(auth);\n  }\n  async getWalletClient() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    // const chain = this.chains.find((x) => x.id === chainId);\n    if (!provider) throw new Error('provider is required.');\n    return createWalletClient({\n      account,\n      chainId,\n      provider\n    });\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    try {\n      await provider.disconnect();\n    } catch (error) {\n      if (!/No matching key/i.test(error.message)) throw error;\n    } finally {\n      this.removeAllListeners();\n    }\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    console.log('getAccount', accounts);\n    return ethers.getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId,\n      getChainId,\n      request\n    } = await this.getProvider();\n    if (!chainId) {\n      const chain = await getChainId();\n      console.log('chain', chain);\n      return Number(chain.split(':')[1]);\n    }\n    return chainId;\n  }\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.provider) await this.createProvider();\n    if (chainId) await this.switchChain(chainId || this.chains[0].id);\n    return this.provider;\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n      // If an account does not exist on the session, then the connector is unauthorized.\n      if (!account) return false;\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain => chain.id === chainId);\n    // if (!chain) throw new Error('chain not found on connector.');\n    // if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n    try {\n      // const provider = await this.getProvider();\n\n      // const chains = await provider.request({\n      //     method: 'wallet_switchEthereumChain',\n      //     params: [{ chainId: `${ethers.toBeHex(chainId)}` }],\n      // });\n\n      // console.log('chains', chains);\n\n      return chain;\n    } catch (error) {\n      console.log('error', error);\n      // const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n      // if (/user rejected request/i.test(message)) {\n      //     throw new UserRejectedRequestError(error as Error);\n      // }\n      // throw new SwitchChainError(error as Error);\n    }\n  }\n\n  async createProvider() {\n    return this.initProvider();\n  }\n  async initProvider() {\n    const [defaultChain, ...optionalChains] = this.chains.map(_ref => {\n      let {\n        id\n      } = _ref;\n      return id;\n    });\n    if (defaultChain) {\n      this.provider = await MiraiProvider.init({\n        chains: [defaultChain]\n        // rpcMap: Object.fromEntries(this.chains.map((chain) => [chain.id, chain.rpcUrls.default.http[0]!])),\n      });\n    }\n\n    console.log('provider', this.provider);\n  }\n  setupListeners() {\n    if (!this.provider) return;\n    this.removeListeners();\n    this.provider.on('accountsChanged', this.onAccountsChanged);\n    this.provider.on('chainChanged', this.onChainChanged);\n    this.provider.on('disconnect', this.onDisconnect);\n    this.provider.on('connect', this.onConnect);\n  }\n  removeListeners() {\n    if (!this.provider) return;\n    this.provider.removeListener('accountsChanged', this.onAccountsChanged);\n    this.provider.removeListener('chainChanged', this.onChainChanged);\n    this.provider.removeListener('disconnect', this.onDisconnect);\n    this.provider.removeListener('connect', this.onConnect);\n  }\n}\n\n// export default MiraiConnector;","map":{"version":3,"names":["Connector","MiraiProvider","ethers","createWalletClient","AuthToken","ETH_CHAIN_ID","getPeer","peer","MiraiConnector","constructor","config","_objectSpread","options","isNewChainsStale","_defineProperty","accounts","length","emit","account","getAddress","chainId","id","Number","unsupported","isChainUnsupported","chain","uri","type","data","createProvider","connect","pairingTopic","arguments","undefined","provider","getProvider","setupListeners","chains","enable","console","log","getChainId","parseInt","error","setWalletAuthentication","auth","save","getWalletClient","Promise","all","getAccount","Error","disconnect","test","message","removeAllListeners","request","split","switchChain","isAuthorized","find","initProvider","defaultChain","optionalChains","map","_ref","init","removeListeners","on","onAccountsChanged","onChainChanged","onDisconnect","onConnect","removeListener"],"sources":["/Users/phuocnd/phuocnd/works/mirai/miraiidjs/src/sign-provider/connectors/mirai-connector.ts"],"sourcesContent":["import { Connector } from '../connectors/connector';\nimport { MiraiProvider, ConnectOps } from '../providers/mirai-provider';\nimport { ethers } from 'ethers';\nimport { IWalletClient, createWalletClient } from '../clients/wallet-client';\nimport { Chain } from '../services/core/config';\nimport { AuthToken, auth } from '../../auth-client';\n\nconst ETH_CHAIN_ID = 1;\n\nconst getPeer = (peer: {\n\tpublicKey: string;\n\tmetadata: {\n\t\tname: string;\n\t\tdescription: string;\n\t\turl: string;\n\t\ticons: [];\n\t};\n}) => {};\n\nexport class MiraiConnector extends Connector<MiraiProvider, any> {\n\treadonly id = 'miraijsConnect';\n\treadonly name = 'miraijsConnect';\n\treadonly ready = true;\n\n\tprovider?: MiraiProvider;\n\n\tconstructor(config: { chains?: Chain[]; options: any }) {\n\t\tsuper({\n\t\t\t...config,\n\t\t\toptions: { isNewChainsStale: true, ...config.options },\n\t\t});\n\t\tthis.createProvider();\n\t}\n\n\tasync connect({ chainId, pairingTopic }: ConnectOps = { chainId: ETH_CHAIN_ID }) {\n\t\ttry {\n\t\t\tconst provider = await this.getProvider();\n\t\t\tthis.setupListeners();\n\n\t\t\tthis.emit('message', { type: 'connecting. scan qrcode ...' });\n\n\t\t\tawait provider.connect({\n\t\t\t\tpairingTopic,\n\t\t\t\tchains: [chainId],\n\t\t\t\tchainId,\n\t\t\t});\n\n\t\t\tthis.emit('message', { type: 'connected' });\n\n\t\t\t// If session exists and chains are authorized, enable provider for required chain\n\t\t\tconst accounts = await provider.enable();\n\n\t\t\t// await this.switchChain(chainId);\n\n\t\t\tconsole.log('accounts', accounts);\n\n\t\t\tconst account = ethers.getAddress(accounts[0]);\n\t\t\tconst chain = await provider.getChainId();\n\t\t\tconst id = Number(parseInt(chain, 16));\n\t\t\tconst unsupported = this.isChainUnsupported(id);\n\n\t\t\treturn {\n\t\t\t\taccount,\n\t\t\t\tchain: { id, unsupported },\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// if (/user rejected/i.test((eror as ProviderRpcError)?.message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync setWalletAuthentication(auth: auth.TMiraiAccessToken) {\n\t\tawait AuthToken.save(auth);\n\t}\n\n\tasync getWalletClient({ chainId }: { chainId?: number } = {}): Promise<IWalletClient> {\n\t\tconst [provider, account] = await Promise.all([this.getProvider({ chainId }), this.getAccount()]);\n\t\t// const chain = this.chains.find((x) => x.id === chainId);\n\t\tif (!provider) throw new Error('provider is required.');\n\t\treturn createWalletClient({\n\t\t\taccount,\n\t\t\tchainId,\n\t\t\tprovider,\n\t\t});\n\t}\n\n\tasync disconnect() {\n\t\tconst provider = await this.getProvider();\n\t\ttry {\n\t\t\tawait provider.disconnect();\n\t\t} catch (error) {\n\t\t\tif (!/No matching key/i.test((error as Error).message)) throw error;\n\t\t} finally {\n\t\t\tthis.removeAllListeners();\n\t\t}\n\t}\n\n\tasync getAccount(): Promise<string> {\n\t\tconst { accounts } = await this.getProvider();\n\n\t\tconsole.log('getAccount', accounts);\n\t\treturn ethers.getAddress(accounts[0]!);\n\t}\n\n\tasync getChainId() {\n\t\tconst { chainId, getChainId, request } = await this.getProvider();\n\t\tif (!chainId) {\n\t\t\tconst chain = await getChainId();\n\t\t\tconsole.log('chain', chain);\n\t\t\treturn Number(chain.split(':')[1]);\n\t\t}\n\t\treturn chainId;\n\t}\n\n\tasync getProvider({ chainId }: { chainId?: number } = {}) {\n\t\tif (!this.provider) await this.createProvider();\n\t\tif (chainId) await this.switchChain(chainId || this.chains[0].id);\n\t\treturn this.provider;\n\t}\n\n\tasync isAuthorized() {\n\t\ttry {\n\t\t\tconst [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n\n\t\t\t// If an account does not exist on the session, then the connector is unauthorized.\n\t\t\tif (!account) return false;\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync switchChain(chainId: number) {\n\t\tconst chain = this.chains.find((chain) => chain.id === chainId);\n\t\t// if (!chain) throw new Error('chain not found on connector.');\n\t\t// if (!chain) throw new SwitchChainError(new Error('chain not found on connector.'));\n\n\t\ttry {\n\t\t\t// const provider = await this.getProvider();\n\n\t\t\t// const chains = await provider.request({\n\t\t\t//     method: 'wallet_switchEthereumChain',\n\t\t\t//     params: [{ chainId: `${ethers.toBeHex(chainId)}` }],\n\t\t\t// });\n\n\t\t\t// console.log('chains', chains);\n\n\t\t\treturn chain;\n\t\t} catch (error) {\n\t\t\tconsole.log('error', error);\n\t\t\t// const message = typeof error === 'string' ? error : (error as ProviderRpcError)?.message;\n\t\t\t// if (/user rejected request/i.test(message)) {\n\t\t\t//     throw new UserRejectedRequestError(error as Error);\n\t\t\t// }\n\t\t\t// throw new SwitchChainError(error as Error);\n\t\t}\n\t}\n\n\tasync createProvider() {\n\t\treturn this.initProvider();\n\t}\n\n\tasync initProvider() {\n\t\tconst [defaultChain, ...optionalChains] = this.chains.map(({ id }) => id);\n\t\tif (defaultChain) {\n\t\t\tthis.provider = await MiraiProvider.init({\n\t\t\t\tchains: [defaultChain],\n\t\t\t\t// rpcMap: Object.fromEntries(this.chains.map((chain) => [chain.id, chain.rpcUrls.default.http[0]!])),\n\t\t\t});\n\t\t}\n\n\t\tconsole.log('provider', this.provider);\n\t}\n\n\tsetupListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.removeListeners();\n\t\tthis.provider.on('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.on('chainChanged', this.onChainChanged);\n\t\tthis.provider.on('disconnect', this.onDisconnect);\n\t\tthis.provider.on('connect', this.onConnect);\n\t}\n\n\tremoveListeners() {\n\t\tif (!this.provider) return;\n\t\tthis.provider.removeListener('accountsChanged', this.onAccountsChanged);\n\t\tthis.provider.removeListener('chainChanged', this.onChainChanged);\n\t\tthis.provider.removeListener('disconnect', this.onDisconnect);\n\t\tthis.provider.removeListener('connect', this.onConnect);\n\t}\n\n\tprotected onAccountsChanged = (accounts: string[]) => {\n\t\tif (accounts.length === 0) this.emit('disconnect');\n\t\telse this.emit('change', { account: ethers.getAddress(accounts[0]!) });\n\t};\n\n\tprotected onChainChanged = (chainId: number | string) => {\n\t\tconst id = Number(chainId);\n\t\tconst unsupported = this.isChainUnsupported(id);\n\t\tthis.emit('change', { chain: { id, unsupported } });\n\t};\n\n\tprotected onDisconnect = () => {\n\t\tthis.emit('disconnect');\n\t};\n\n\tprotected onDisplayUri = (uri: string) => {\n\t\tthis.emit('message', { type: 'display_uri', data: uri });\n\t};\n\n\tprotected onConnect = () => {\n\t\tthis.emit('connect', {});\n\t};\n}\n\n// export default MiraiConnector;\n"],"mappings":";;;AAAA,SAASA,SAAS,QAAQ,yBAAyB;AACnD,SAASC,aAAa,QAAoB,6BAA6B;AACvE,SAASC,MAAM,QAAQ,QAAQ;AAC/B,SAAwBC,kBAAkB,QAAQ,0BAA0B;AAE5E,SAASC,SAAS,QAAc,mBAAmB;AAEnD,MAAMC,YAAY,GAAG,CAAC;AAEtB,MAAMC,OAAO,GAAIC,IAQhB,IAAK,CAAC,CAAC;AAER,OAAO,MAAMC,cAAc,SAASR,SAAS,CAAqB;EAOjES,WAAWA,CAACC,MAA0C,EAAE;IACvD,KAAK,CAAAC,aAAA,CAAAA,aAAA,KACDD,MAAM;MACTE,OAAO,EAAAD,aAAA;QAAIE,gBAAgB,EAAE;MAAI,GAAKH,MAAM,CAACE,OAAO;IAAE,EACtD,CAAC;IAACE,eAAA,aAVU,gBAAgB;IAAAA,eAAA,eACd,gBAAgB;IAAAA,eAAA,gBACf,IAAI;IAAAA,eAAA;IAAAA,eAAA,4BA4KUC,QAAkB,IAAK;MACrD,IAAIA,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE,IAAI,CAACC,IAAI,CAAC,YAAY,CAAC,CAAC,KAC9C,IAAI,CAACA,IAAI,CAAC,QAAQ,EAAE;QAAEC,OAAO,EAAEhB,MAAM,CAACiB,UAAU,CAACJ,QAAQ,CAAC,CAAC,CAAE;MAAE,CAAC,CAAC;IACvE,CAAC;IAAAD,eAAA,yBAE2BM,OAAwB,IAAK;MACxD,MAAMC,EAAE,GAAGC,MAAM,CAACF,OAAO,CAAC;MAC1B,MAAMG,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAACH,EAAE,CAAC;MAC/C,IAAI,CAACJ,IAAI,CAAC,QAAQ,EAAE;QAAEQ,KAAK,EAAE;UAAEJ,EAAE;UAAEE;QAAY;MAAE,CAAC,CAAC;IACpD,CAAC;IAAAT,eAAA,uBAEwB,MAAM;MAC9B,IAAI,CAACG,IAAI,CAAC,YAAY,CAAC;IACxB,CAAC;IAAAH,eAAA,uBAEyBY,GAAW,IAAK;MACzC,IAAI,CAACT,IAAI,CAAC,SAAS,EAAE;QAAEU,IAAI,EAAE,aAAa;QAAEC,IAAI,EAAEF;MAAI,CAAC,CAAC;IACzD,CAAC;IAAAZ,eAAA,oBAEqB,MAAM;MAC3B,IAAI,CAACG,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;IACzB,CAAC;IAxLA,IAAI,CAACY,cAAc,CAAC,CAAC;EACtB;EAEA,MAAMC,OAAOA,CAAA,EAAoE;IAAA,IAAnE;MAAEV,OAAO;MAAEW;IAAyB,CAAC,GAAAC,SAAA,CAAAhB,MAAA,QAAAgB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG;MAAEZ,OAAO,EAAEf;IAAa,CAAC;IAC9E,IAAI;MACH,MAAM6B,QAAQ,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC;MACzC,IAAI,CAACC,cAAc,CAAC,CAAC;MAErB,IAAI,CAACnB,IAAI,CAAC,SAAS,EAAE;QAAEU,IAAI,EAAE;MAA8B,CAAC,CAAC;MAE7D,MAAMO,QAAQ,CAACJ,OAAO,CAAC;QACtBC,YAAY;QACZM,MAAM,EAAE,CAACjB,OAAO,CAAC;QACjBA;MACD,CAAC,CAAC;MAEF,IAAI,CAACH,IAAI,CAAC,SAAS,EAAE;QAAEU,IAAI,EAAE;MAAY,CAAC,CAAC;;MAE3C;MACA,MAAMZ,QAAQ,GAAG,MAAMmB,QAAQ,CAACI,MAAM,CAAC,CAAC;;MAExC;;MAEAC,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEzB,QAAQ,CAAC;MAEjC,MAAMG,OAAO,GAAGhB,MAAM,CAACiB,UAAU,CAACJ,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC9C,MAAMU,KAAK,GAAG,MAAMS,QAAQ,CAACO,UAAU,CAAC,CAAC;MACzC,MAAMpB,EAAE,GAAGC,MAAM,CAACoB,QAAQ,CAACjB,KAAK,EAAE,EAAE,CAAC,CAAC;MACtC,MAAMF,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAACH,EAAE,CAAC;MAE/C,OAAO;QACNH,OAAO;QACPO,KAAK,EAAE;UAAEJ,EAAE;UAAEE;QAAY;MAC1B,CAAC;IACF,CAAC,CAAC,OAAOoB,KAAK,EAAE;MACf;MACA;MACA;MACA,MAAMA,KAAK;IACZ;EACD;EAEA,MAAMC,uBAAuBA,CAACC,IAA4B,EAAE;IAC3D,MAAMzC,SAAS,CAAC0C,IAAI,CAACD,IAAI,CAAC;EAC3B;EAEA,MAAME,eAAeA,CAAA,EAAiE;IAAA,IAAhE;MAAE3B;IAA8B,CAAC,GAAAY,SAAA,CAAAhB,MAAA,QAAAgB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IAC3D,MAAM,CAACE,QAAQ,EAAEhB,OAAO,CAAC,GAAG,MAAM8B,OAAO,CAACC,GAAG,CAAC,CAAC,IAAI,CAACd,WAAW,CAAC;MAAEf;IAAQ,CAAC,CAAC,EAAE,IAAI,CAAC8B,UAAU,CAAC,CAAC,CAAC,CAAC;IACjG;IACA,IAAI,CAAChB,QAAQ,EAAE,MAAM,IAAIiB,KAAK,CAAC,uBAAuB,CAAC;IACvD,OAAOhD,kBAAkB,CAAC;MACzBe,OAAO;MACPE,OAAO;MACPc;IACD,CAAC,CAAC;EACH;EAEA,MAAMkB,UAAUA,CAAA,EAAG;IAClB,MAAMlB,QAAQ,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC;IACzC,IAAI;MACH,MAAMD,QAAQ,CAACkB,UAAU,CAAC,CAAC;IAC5B,CAAC,CAAC,OAAOT,KAAK,EAAE;MACf,IAAI,CAAC,kBAAkB,CAACU,IAAI,CAAEV,KAAK,CAAWW,OAAO,CAAC,EAAE,MAAMX,KAAK;IACpE,CAAC,SAAS;MACT,IAAI,CAACY,kBAAkB,CAAC,CAAC;IAC1B;EACD;EAEA,MAAML,UAAUA,CAAA,EAAoB;IACnC,MAAM;MAAEnC;IAAS,CAAC,GAAG,MAAM,IAAI,CAACoB,WAAW,CAAC,CAAC;IAE7CI,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEzB,QAAQ,CAAC;IACnC,OAAOb,MAAM,CAACiB,UAAU,CAACJ,QAAQ,CAAC,CAAC,CAAE,CAAC;EACvC;EAEA,MAAM0B,UAAUA,CAAA,EAAG;IAClB,MAAM;MAAErB,OAAO;MAAEqB,UAAU;MAAEe;IAAQ,CAAC,GAAG,MAAM,IAAI,CAACrB,WAAW,CAAC,CAAC;IACjE,IAAI,CAACf,OAAO,EAAE;MACb,MAAMK,KAAK,GAAG,MAAMgB,UAAU,CAAC,CAAC;MAChCF,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEf,KAAK,CAAC;MAC3B,OAAOH,MAAM,CAACG,KAAK,CAACgC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACnC;IACA,OAAOrC,OAAO;EACf;EAEA,MAAMe,WAAWA,CAAA,EAAyC;IAAA,IAAxC;MAAEf;IAA8B,CAAC,GAAAY,SAAA,CAAAhB,MAAA,QAAAgB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IACvD,IAAI,CAAC,IAAI,CAACE,QAAQ,EAAE,MAAM,IAAI,CAACL,cAAc,CAAC,CAAC;IAC/C,IAAIT,OAAO,EAAE,MAAM,IAAI,CAACsC,WAAW,CAACtC,OAAO,IAAI,IAAI,CAACiB,MAAM,CAAC,CAAC,CAAC,CAAChB,EAAE,CAAC;IACjE,OAAO,IAAI,CAACa,QAAQ;EACrB;EAEA,MAAMyB,YAAYA,CAAA,EAAG;IACpB,IAAI;MACH,MAAM,CAACzC,OAAO,EAAEgB,QAAQ,CAAC,GAAG,MAAMc,OAAO,CAACC,GAAG,CAAC,CAAC,IAAI,CAACC,UAAU,CAAC,CAAC,EAAE,IAAI,CAACf,WAAW,CAAC,CAAC,CAAC,CAAC;;MAEtF;MACA,IAAI,CAACjB,OAAO,EAAE,OAAO,KAAK;MAE1B,OAAO,IAAI;IACZ,CAAC,CAAC,MAAM;MACP,OAAO,KAAK;IACb;EACD;EAEA,MAAMwC,WAAWA,CAACtC,OAAe,EAAE;IAClC,MAAMK,KAAK,GAAG,IAAI,CAACY,MAAM,CAACuB,IAAI,CAAEnC,KAAK,IAAKA,KAAK,CAACJ,EAAE,KAAKD,OAAO,CAAC;IAC/D;IACA;;IAEA,IAAI;MACH;;MAEA;MACA;MACA;MACA;;MAEA;;MAEA,OAAOK,KAAK;IACb,CAAC,CAAC,OAAOkB,KAAK,EAAE;MACfJ,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEG,KAAK,CAAC;MAC3B;MACA;MACA;MACA;MACA;IACD;EACD;;EAEA,MAAMd,cAAcA,CAAA,EAAG;IACtB,OAAO,IAAI,CAACgC,YAAY,CAAC,CAAC;EAC3B;EAEA,MAAMA,YAAYA,CAAA,EAAG;IACpB,MAAM,CAACC,YAAY,EAAE,GAAGC,cAAc,CAAC,GAAG,IAAI,CAAC1B,MAAM,CAAC2B,GAAG,CAACC,IAAA;MAAA,IAAC;QAAE5C;MAAG,CAAC,GAAA4C,IAAA;MAAA,OAAK5C,EAAE;IAAA,EAAC;IACzE,IAAIyC,YAAY,EAAE;MACjB,IAAI,CAAC5B,QAAQ,GAAG,MAAMjC,aAAa,CAACiE,IAAI,CAAC;QACxC7B,MAAM,EAAE,CAACyB,YAAY;QACrB;MACD,CAAC,CAAC;IACH;;IAEAvB,OAAO,CAACC,GAAG,CAAC,UAAU,EAAE,IAAI,CAACN,QAAQ,CAAC;EACvC;EAEAE,cAAcA,CAAA,EAAG;IAChB,IAAI,CAAC,IAAI,CAACF,QAAQ,EAAE;IACpB,IAAI,CAACiC,eAAe,CAAC,CAAC;IACtB,IAAI,CAACjC,QAAQ,CAACkC,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAACC,iBAAiB,CAAC;IAC3D,IAAI,CAACnC,QAAQ,CAACkC,EAAE,CAAC,cAAc,EAAE,IAAI,CAACE,cAAc,CAAC;IACrD,IAAI,CAACpC,QAAQ,CAACkC,EAAE,CAAC,YAAY,EAAE,IAAI,CAACG,YAAY,CAAC;IACjD,IAAI,CAACrC,QAAQ,CAACkC,EAAE,CAAC,SAAS,EAAE,IAAI,CAACI,SAAS,CAAC;EAC5C;EAEAL,eAAeA,CAAA,EAAG;IACjB,IAAI,CAAC,IAAI,CAACjC,QAAQ,EAAE;IACpB,IAAI,CAACA,QAAQ,CAACuC,cAAc,CAAC,iBAAiB,EAAE,IAAI,CAACJ,iBAAiB,CAAC;IACvE,IAAI,CAACnC,QAAQ,CAACuC,cAAc,CAAC,cAAc,EAAE,IAAI,CAACH,cAAc,CAAC;IACjE,IAAI,CAACpC,QAAQ,CAACuC,cAAc,CAAC,YAAY,EAAE,IAAI,CAACF,YAAY,CAAC;IAC7D,IAAI,CAACrC,QAAQ,CAACuC,cAAc,CAAC,SAAS,EAAE,IAAI,CAACD,SAAS,CAAC;EACxD;AAwBD;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}